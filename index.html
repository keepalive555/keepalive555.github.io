<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="枫叶居" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="枫叶居">
<meta property="og:url" content="https://blog.nice-ai-life.com/index.html">
<meta property="og:site_name" content="枫叶居">
<meta property="og:description" content="技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="枫叶居">
<meta name="twitter:description" content="技术博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.nice-ai-life.com/"/>





  <title> 枫叶居 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <a href="https://github.com/keepalive555" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">枫叶居</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">桃李春风一杯酒，江湖夜雨十年灯</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2018/02/03/bloom-filter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/03/bloom-filter/" itemprop="url">
                  bloom filter（布隆过滤器）
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T00:21:14+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在互联网后台的开发工作中，笔者会经常遇到各种各样的<strong><em>白名单</em></strong>业务场景，比如以下典型场景：</p>
<ol>
<li>现有1亿个用户<code>user_id</code>，如何快速判断一个<code>user_id</code>是否在该白名单内</li>
<li>网络爬虫解析出一个页面的<code>url</code>清单，如何快速判断该<code>url</code>是否已经被抓取过</li>
<li>现有1亿个<code>user_id</code>，如何快速判断哪些<code>user_id</code>曾重复出现</li>
<li>服务器收到来自某个<code>ip</code>地址的请求，快速判断该<code>ip</code>地址是否在黑名单</li>
<li>……</li>
</ol>
<p>熟悉数据结构的读者，略微思考一下，便知以上若干问题的核心需求是：<strong><em>设计一个内存占用少且又高效的查找算法/数据结构。</em></strong> 以场景1为例，大多数读者首先想到的数据结构为<strong><em>哈希表</em></strong>，任意元素均可在<code>O(1)</code>时间复杂度内快速完成查找。</p>
<p>假设哈希表的装载因子为0.5（实践中比较常见的取值），粗略计算一下1亿个int类型<code>user_id</code>的内存占用约为<code>745MB</code>，一个白名单要占用如此多的内存空间，这显然是不可接受的。那么我们如何既能达成我们的目的，又占用比较小的内存呢？</p>
<p>一个<code>user_id</code>是否在白名单之内，只可能存在两种取值——是/否，从<strong><em>香农信息论</em></strong> 角度来看，使用1个<code>bit</code>即可表示是/否两种取值。一个<code>int</code>类型变量可存储<code>2^32</code>种取值，而当前业务场景下我们仅仅需要<code>0</code>和<code>1</code>两种状态便可（存储4种状态使用2个<code>bit</code>，存储8种状态使用3个<code>bit</code>，以此类推…）。存储1亿个<code>bit</code>占用空间约为<code>11MB</code>，大大减少了内存占用，这便是<code>Bitmap</code>数据结构。</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p><code>Bitmap</code>是一种紧凑的数据结构。以场景1为例，首先在内存中连续分配1亿个<code>bit</code>，要判断<code>user_id</code>为<code>1000</code>的用户是否在白名单之内，只需获取<code>bit</code>序列的第<code>1000</code>位<code>bit</code>的状态（1：<code>user_id</code>在白名单，0：<code>user_id</code>不在白名单）。如下为<code>c</code>语言版本的示例代码（也可查看笔者的<a href="https://github.com/keepalive555/study/blob/master/bitmap/bitmap.c" target="_blank" rel="external"><code>github</code></a>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1024</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0xffffffff</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> bitmap[MAXSIZE / (<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) * <span class="number">8</span>) + <span class="number">1</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 置位操作</span></div><div class="line">    bitmap[n &gt;&gt; SHIFT] |= <span class="number">1</span> &lt;&lt; (n &amp; MASK);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 复位操作</span></div><div class="line">    bitmap[n &gt;&gt; SHIFT] &amp;= ~(<span class="number">1</span> &lt;&lt; (n &amp; MASK));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检测是否置位</span></div><div class="line">    <span class="keyword">int</span> i = n &gt;&gt; SHIFT;</div><div class="line">    <span class="keyword">if</span>(bitmap[i] &amp; (<span class="number">1</span> &lt;&lt; (n &amp; MASK)))</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">1023</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"space: %d\n"</span>, <span class="keyword">sizeof</span>(bitmap) / <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));</div><div class="line">    <span class="built_in">set</span>(n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"has set flag: %d\n"</span>, test(n));</div><div class="line">    clr(n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"has set flag: %d\n"</span>, test(n));</div><div class="line">    <span class="built_in">set</span>(n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"has set flag: %d\n"</span>, test(n));</div><div class="line">    clr(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Bitmap</code>类似于哈希表，哈希规则便是将数字<code>n</code>映射到<code>Bitmap</code>第<code>n</code>个<code>bit</code>上。因此<code>Bitmap</code>在实际应用中存在一处问题——当<code>n</code>取值特别大时，<code>Bitmap</code>占用空间也会比较大。在此业务场景下，<code>Bitmap</code>数据结构是不合理的，所以便衍生出了<code>Bloom Filter</code>。</p>
<h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><p><code>Bloom Filter</code>，中文译名布隆过滤器，是1970年由布隆提出来。布隆过滤器可以用于检索一个元素是否在一个集合中。布隆过滤器优点是<em><br><strong>空间复杂度和时间复杂度</strong></em> 都优于一般的算法，缺点是<strong><em>有一定的误识别率</em></strong> ，删除困难。</p>
<p><img src="/2018/02/03/bloom-filter/bloom-filter.png" alt="布隆过滤器"></p>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>假设所选<code>Hash</code>函数在散列空间内分布均匀，即散列到每一个位置的概率相等（对于Hash函数的核心诉求）。假设<code>Bit</code>数组的大小为<code>m</code>，<code>k</code>为<code>Hash</code>函数的个数。</p>
<p><code>Bit</code>数组中某一位位置在元素插入时的<code>Hash</code>操作中没有被置位<code>1</code>的概率是：</p>
<h3 id="概率估算"><a href="#概率估算" class="headerlink" title="概率估算"></a>概率估算</h3><p><a href="http://matthias.vallentin.net/course-work/cs270-s11.pdf" target="_blank" rel="external">Bloom Filter Pagers</a></p>
<p><a href="https://my.oschina.net/kiwivip/blog/133498" target="_blank" rel="external">Bloom Filter算法简介</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2018/01/08/Python-list实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/08/Python-list实现/" itemprop="url">
                  Python list实现
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-08T21:57:35+08:00">
                2018-01-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文所讲<code>Python</code>实现均为<code>CPython</code>，需读者具备一定的<code>C</code>语言阅读能力。本博文参考了<strong><em>《Python源码剖析》</em></strong>与<code>Python2.7</code>源码。<code>PyListObject</code>采用顺序存储（而非链式存储），熟悉<code>数据结构</code>的读者，能很容易明白本博文所讲内容。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>PyListObject</code>是<code>Python</code>提供的<code>List</code>容器实现，与<code>C++ STL</code>中的<code>vector</code>实现机制相近。<code>PyListObject</code>是变长对象同时也是可变对象（很显然，不同时刻<code>List</code>中可以存在不同数目的元素）。</p>
<p><code>PyListObject</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	PyObject_VAR_HEAD</div><div class="line">	PyObject **ob_item;</div><div class="line">	<span class="keyword">int</span> allocated;</div><div class="line">&#125; PyListObject;</div></pre></td></tr></table></figure>
<p><code>PyObject_VAR_HEAD</code>中的<code>ob_size</code>与<code>PyListObject</code>中的<code>allocated</code>字段分别标识了容器的现有<strong><em>元素个数（size）</em></strong>与<strong><em>容器容量（capacity）</em></strong>。<code>ob_item</code>为指向<code>PyObject *</code>的指针（即<code>PyObject *</code>数组），是<code>PyListObject</code>实现顺序存储的数组。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1、创建对象"><a href="#1、创建对象" class="headerlink" title="1、创建对象"></a>1、创建对象</h3><p><code>Python</code>提供了唯一创建<code>List</code>的函数——<code>PyList_New</code>。下面是简化的后<code>Python</code>创建<code>PyListObject</code>对象的过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFREELISTS 80</span></div><div class="line"><span class="keyword">static</span> PyListObject *free_lists[MAXFREELISTS];</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> num_free_ists = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function">PyObject *<span class="title">PyList_New</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">	PyListObject *op;</div><div class="line">	<span class="keyword">size_t</span> nbytes;</div><div class="line">	<span class="comment">// 判断int类型是否溢出，若溢出则返回内存分配失败</span></div><div class="line">	nbytes = size * <span class="keyword">sizeof</span>(PyObject *);</div><div class="line">	<span class="keyword">if</span>(nbytes / <span class="keyword">sizeof</span>(PyObject *) != (<span class="keyword">size_t</span>)size) &#123;</div><div class="line">		<span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="keyword">if</span>(num_free_lists) &#123;</div><div class="line">		<span class="comment">// 缓冲池可用，则从缓冲池取一可用List</span></div><div class="line">		num_free_lists--;</div><div class="line">		op = free_lists[num_free_lists];</div><div class="line">		_Py_NewReference((PyObject *)op);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// 缓冲池不可用，直接新建对象并为Python中的自动垃圾收集机制做一些工作</span></div><div class="line">		op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>(size &lt;= <span class="number">0</span>) &#123;</div><div class="line">		op-&gt;ob_item = <span class="literal">NULL</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		op-&gt;ob_item = (PyObject **)PyMem_MALLOC(nbytes);</div><div class="line">		<span class="built_in">memset</span>(op-&gt;ob_item, <span class="number">0</span>, nbytes);</div><div class="line">	&#125;</div><div class="line">	op-&gt;ob_size = size;</div><div class="line">	op-&gt;allocated = size;</div><div class="line">	<span class="keyword">return</span> (PyObject *)op;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PyListObject</code>对象分为两部分：①<code>PyListObject</code>对象②<code>PyListObject</code>对象容纳的<code>PyObject</code>元素。</p>
<h3 id="2、设置元素"><a href="#2、设置元素" class="headerlink" title="2、设置元素"></a>2、设置元素</h3><p>前面提到<code>PyListObject</code>是顺序存储，可以<strong><em>随机访问</em></strong>。通过下标设置<code>List</code>中元素值，是由<code>PyList_SetItem</code>函数实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyList_SetItem</span><span class="params">(<span class="keyword">register</span> PyObject *op, <span class="keyword">register</span> <span class="keyword">int</span> i, <span class="keyword">register</span> PyObject *new_item)</span> </span>&#123;</div><div class="line"> 	<span class="comment">// 保存指向旧元素的指针，用于减少引用计数</span></div><div class="line">	<span class="keyword">register</span> PyObject *olditem;</div><div class="line">	<span class="keyword">register</span> PyObject **p;</div><div class="line">	<span class="comment">// 检查索引值得合法性</span></div><div class="line">	<span class="keyword">if</span>(i &lt; <span class="number">0</span> || i&gt;= (PyListObject)op-&gt;ob_size) &#123;</div><div class="line">		<span class="comment">// 报索引错误</span></div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 设置元素</span></div><div class="line">	p = ((PyListObject*)op)-&gt;ob_item + i;</div><div class="line">	olditem = *p;</div><div class="line">	Py_XDECREF(olditem);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、插入元素"><a href="#3、插入元素" class="headerlink" title="3、插入元素"></a>3、插入元素</h3><p>了解<code>顺序存储</code>的读者，很容易想到新元素的插入会导致元素的移动。<code>PyListObject</code>的实现也不例外，而这其中又牵扯了<code>PyListObject.ob_item</code>的<strong><em>扩容</em></strong>与<strong><em>缩容</em></strong>（参考<code>Redis</code>或者其它若干软件的实现，都会有类似机制）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyList_Insert</span><span class="params">(PyObject *op, Py_ssize_t where, PyObject *new_item)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> insl((PyListObject *)op, where, newitem);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insl</span><span class="params">(PyListObject *self, Py_ssize_t where, PyObject *v)</span> </span>&#123;</div><div class="line">	Py_ssize_t i, n = self-&gt;ob_size;</div><div class="line">	PyObject **items;</div><div class="line">	<span class="comment">// 调整列表容量</span></div><div class="line">	<span class="keyword">if</span>(list_resize(self, n+<span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	<span class="comment">// 确定插入点</span></div><div class="line">	<span class="keyword">if</span>(where &lt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// 负数索引</span></div><div class="line">		where += n;</div><div class="line">		<span class="keyword">if</span>(where &lt; <span class="number">0</span>)</div><div class="line">			where = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(where &gt; n)</div><div class="line">		where = n;</div><div class="line">	<span class="comment">// 插入元素</span></div><div class="line">	items = self-&gt;ob_item;</div><div class="line">	<span class="keyword">for</span>(i = n; --i &gt;= where; )</div><div class="line">		<span class="comment">// 从后往前将元素后移一个单位，空出新元素存储单元</span></div><div class="line">		item[i+<span class="number">1</span>] = item[i]</div><div class="line">	<span class="comment">// 使用宏Py_INCREF增加元素v的引用计数</span></div><div class="line">	Py_INCREF(v);</div><div class="line">	item[where] = v;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中函数<code>list_resize</code>为<code>PyListObject</code>对象<strong><em>扩容</em></strong>与<strong><em>缩容</em></strong>的关键。<code>list_resize</code>函数的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_resize</span><span class="params">(PyObjectList *self, <span class="keyword">int</span> newsize)</span> </span>&#123;</div><div class="line">	PyObject **items;</div><div class="line">	<span class="keyword">size_t</span> new_allocated;</div><div class="line">	<span class="keyword">int</span> allocated = self-&gt;allocated;</div><div class="line">	<span class="comment">// 不需要申请内存</span></div><div class="line">	<span class="keyword">if</span>(allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">		self-&gt;ob_size = newsize;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 计算重新申请内存的大小</span></div><div class="line">	new_allocated = (newsize &gt;&gt; <span class="number">3</span>) + (newsize &lt; <span class="number">9</span> ? <span class="number">3</span> : <span class="number">6</span>) + newsize;</div><div class="line">	<span class="keyword">if</span>(newsize == <span class="number">0</span>)</div><div class="line">		new_allocated = <span class="number">0</span>;</div><div class="line">	<span class="comment">// 扩展列表</span></div><div class="line">	items = self-&gt;ob_items;</div><div class="line">	<span class="comment">// 最终调用c语言的realloc</span></div><div class="line">	PyMem_RESIZE(item, PyObject *, new_allocated);</div><div class="line">	self-&gt;ob_itme = items;</div><div class="line">	self-&gt;ob_size = newsize;</div><div class="line">	self-&gt;allocated = new_allocated;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>List</code>新的元素个数<code>newsize</code>，满足条件：<code>allocated/2 &lt;= newsize &lt;= allocated</code>时，不需要进行<code>realloc</code>。当<code>newsize &gt;= allocated</code>时，<code>PyObjectList</code>会进行<strong><em>扩容</em></strong>操作，当<code>newsize &lt; allocated/2</code>时<code>PyObjectList</code>会进行<strong><em>缩容</em></strong>操作。</p>
<h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p><code>CPython</code>为了解决频繁创建对象带来的性能问题（大多数对性能要求较高的<code>C</code>程序均采用类似机制），采用了大量的<code>对象池</code>技术——<code>PyListObject</code>的实现也不例外。如果读者对此类技术不熟悉，请参阅<strong><em>对象池</em></strong>设计模式。</p>
<p>在如上<code>PyList_New</code>函数的实现代码中，<code>free_lists</code>指针数组便是用于<code>PyListObject</code>创建的对象池。我们可以看到如果存在可用的<code>PyListObject</code>，<code>Python</code>便会从<code>对象池</code>中取出并返回一个<code>PyListObject</code>对象。那么<code>PyListObject</code>对象是<strong><em>何时、如何</em></strong>归还给对象池的呢？答案就在销毁<code>PyListObject</code>的<code>list_dealloc</code>函数里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_dealloc</span><span class="params">(PyListObject *op)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">if</span>(op-&gt;ob_item != <span class="literal">NULL</span>) &#123;</div><div class="line">		i = op-&gt;ob_size;</div><div class="line">		<span class="keyword">while</span>(--i &gt;= <span class="number">0</span>) &#123;</div><div class="line">			Py_XDECREF(op-&gt;ob_item[i]);</div><div class="line">		&#125;</div><div class="line">		PyMem_FREE(op-&gt;ob_item);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 释放PyListObject自身</span></div><div class="line">	<span class="keyword">if</span>(num_free_lists &lt; MAXFREELISTS &amp;&amp; PyList_CheckExact(op))</div><div class="line">		free_lists[num_free_lists++] = op;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		op-&gt;ob_type-&gt;tp_free((PyObject *)op);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/12/29/SkipList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/29/SkipList/" itemprop="url">
                  SkipList研究
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T00:37:10+08:00">
                2017-12-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>作为一名学渣，每次回头去翻看一下大学课程的基础知识，总会有不同的感受。笔者也总想着把自己工作中领悟的做归纳。关于查找算法，思想大概可以归类为三类（大神请绕路）：</p>
<ul>
<li>顺序查找</li>
<li>二分查找（插入查找、斐波拉切查找…）</li>
<li>哈希查找</li>
</ul>
<p>顺序查找是我们常用的遍历。在对性能要求比较高的业务场景下，我们便需要考虑其他更好的实现方式了（例如：为了避免全表扫描，数据库通过<code>B+ Tree</code>索引提高查找效率）。哈希查找，时间复杂度为<code>O(1)</code>，是一种常见且应用广泛的查找算法。本文将在剩余篇幅对二分查找法进行吐槽。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>咦？今天我们讨论的不是<code>SkipList</code>吗，为什么会谈到二分查找法，接下来笔者将阐述一下原因。在实际工程应用中，算法与数据结构是相辅相成的，相互依存，相互影响的， 没有<code>数据结构</code>支撑的算法只能是空中阁楼。接下来，我们思考尝试为二分查找（或类似思想）寻找一个适合的<strong><em>数据结构</em></strong>。</p>
<p>通常会从<code>CRUD</code>（即增、删、改、查）四个角度，结合具体应用场景去衡量一个数据结构的适用性。我们知道数据的存储方式分为两种：①顺序存储②链式存储。<strong>顺序存储</strong>中，有序列表的元素在内存中紧紧相连，可以<strong><em>随机访问</em></strong>（直接用下标访问，时间复杂度<code>O(1)</code>），能用二分查找法快速定位节点。但是顺序存储对<code>增、删</code>操作的处理比较费力（当删除列表中一个元素时，列表应当将该元素后面的元素前移，填补空的节点，同样增加元素时亦是如此）。</p>
<p>顺序存储不适用于<code>增 、删</code>操作频繁的应用场景，那么我们考虑一下<strong><em>链式存储</em></strong>。<strong><em>链表</em></strong>能很好的处理<code>增、删</code>频繁的场景。但是链表一般<strong><em>顺序访问</em></strong>（即读取第一个元素后才可以读取第二个元素，以此类推），显然传统的链表数据结构无法应用二分的思想进行快速查找。</p>
<p>聪明的人们结合<code>二叉树</code>，发明了<strong><em>二叉查找树</em></strong>———既可以二分查找，又能够快速<code>添加、删除</code>元素的数据结构。这正是我们期望的能够应用二分查找的完美数据结构吗？很遗憾，并不是。二叉查找树在最坏情况下可能变成一个链表。于是，在二分查找树的基础上，就出现了<code>AVL</code>平衡树。<code>AVL</code>树在<code>增、删</code>节点时，为了保持树的平衡，会进行左旋，右旋操作，增加了<code>增、删</code>操作的复杂度。于是乎根据人们在发明了<code>B-Tree</code>，<code>B+ Tree</code>，<code>红黑树</code>等。但是<code>AVL</code>树实现起来比较复杂，平衡操作较难理解。</p>
<p>所以便有了<code>SkipList</code>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>百度搜索网上一些<code>SkipList</code>的实现，代码多多少少存在一些瑕疵。笔者根据自己对<code>SkipList</code>的理解，结合网上的一些实现，整理出了一份<code>C</code>语言版本的<code>SkipList</code>实现。读者可以参阅笔者的<code>GitHub</code>，源文件：<a href="https://github.com/keepalive555/study/blob/master/skiplist/skiplist.c" target="_blank" rel="external">https://github.com/keepalive555/study/blob/master/skiplist/skiplist.c</a>。</p>
<p>其中<code>SkipList</code>新建<code>Node</code>节点，随机获取节点<code>level</code>值的<code>random_level</code>函数（源码如下所示），是笔者摘抄自<code>Redis</code>源码。<strong><em>该函数是保证<code>SkipList</code>的<code>CRUD</code>操作时间复杂度为</em></strong>O(logN)<strong><em>的核心所在</em></strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEVEL 32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> P 0.25</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_level</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">while</span> ((random() &amp; <span class="number">0xFFFF</span>) &lt; (P * <span class="number">0xFFFF</span>))  </div><div class="line">        level += <span class="number">1</span>;  </div><div class="line">    <span class="keyword">return</span> (level &lt; MAX_LEVEL) ? level : MAX_LEVEL;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/12/23/raft协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/23/raft协议/" itemprop="url">
                  Raft协议
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-23T21:14:30+08:00">
                2017-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式，很多初学者对这个词的第一印象——高大上技术范儿。抛开技术细节不谈，纵观后台技术的发展，存在着普遍适用的规律，一项新技术的诞生，总是解决一些现有架构无法解决的问题。如果读者凭空去学习分布式，便容易坠入云里雾里。本文作为笔者自己学习的一个梳理，以实际问题出发阐述了笔者对<code>Raft</code>协议的理解。本文并不对<code>Raft</code>协议的实现机制做详细的描述，只是从一个新手解决问题的角度去阐述<code>Raft</code>协议做了些什么，不正确的地方请读者指正（邮箱：<a href="mailto:dreamcatchwang1991@gmail.com" target="_blank" rel="external">dreamcatchwang1991@gmail.com</a>）。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>以经典单数据库实例架构（这也是很多企业级应用的典型架构）为例，所有的业务数据均存储于单机数据库，当数据库实例<code>Crash</code>了以后，业务便受到影响，在大多数情况下，这种<code>Crash</code>对企业业务的影响是可控范的。然而在互联网应用中，哪怕是一分钟的<code>Crash</code>对企业来说也是致命的，比如前段时间，美团的外卖系统出现崩溃，整个服务停摆几个小时，造成大量用户流失到饿了么平台。 </p>
<p>笔者尝试根据自己的经验去解决该问题，为了让单机数据库实例在<code>Crash</code>了以后,整个系统仍然保持可用，我们很容易想到的一个策略——冗余（比如你在单位请假了需要有人代替你继续工作而不影响业务）。我们增加了一台数据库实例<code>B</code>（原来的数据库实例用<code>A</code>表示），在实例<code>A</code>挂掉了之后，我们期望<code>B</code>可以代替<code>A</code>继续提供服务，<strong><em>所以<code>B</code>与<code>A</code>必须具备一样的数据</em></strong>，在分布式里面这个称作<strong><em>一致性</em></strong>。<code>Raft</code>协议为<strong><em>分布式一致性协议</em></strong>的一种实现，主要目标就是解决上述这类问题。</p>
<p>脱离现有的<code>MySQL</code>，<code>Redis</code>，<code>Kafka</code>等高可用方案（因为这些系统为了性能而做出一些折中），我们根据自己的诉求，去设计一个高可用的存储系统，需要注意哪些问题呢？假设我们的存储系统有<code>A</code>,<code>B</code>,<code>C</code>等3个节点用来保持高可用，那我们该怎么保持<code>A</code>,<code>B</code>,<code>C</code>3个节点内数据的一致性呢？</p>
<ul>
<li>一致性由客户端保证还是服务端保证</li>
<li>如何保证<code>A,B,C</code>或更多节点的数据一致性</li>
</ul>
<p>首先分析第一个问题，假设一致性工作是由客户端保证的（客户端向<code>A</code>写入数据的同时向<code>B</code>和<code>C</code>写入数据，为保证<code>A,B,C</code>的一致性，需<code>A,B,C</code>3个节点全部写入成功，客户端回才判定写入成功），我们可能会遇到如下情况:</p>
<ul>
<li><code>B</code>下线了一段时间又重新上线，因为客户端未保存<code>B</code>处于下线状态这段时间的数据，所以<code>B</code>中就会缺失这部分数据，因而<code>B</code>中数据会与<code>A</code>与<code>C</code>中数据不一致。</li>
<li>客户端向<code>A</code>与<code>C</code>中写入数据成功，但向<code>B</code>中写入数据失败，这次写入应当被认定为失败（因为<code>A</code>,<code>B</code>,<code>C</code>中数据不一致，也无法通过其他途径达到一致），我们期望整个系统可以表现的犹如一个<strong><em>事务</em></strong>，要么全部成功，要么全部失败回滚修改，客户端无法提供这种机制。</li>
</ul>
<p>综上，<strong><em>由客户端保证数据的一致性是不可取的</em></strong>。 </p>
<p>我们将一致性保证工作放在服务端实现，那么我们如何保证<code>A,B,C</code>三节点数据的一致性呢？首先我们思考一个问题，<strong><em>我们无法预知<code>A,B,C</code>三个节点中哪个节点会意外挂掉，所以客户端不应该至同单一节点建立联系</em></strong>，也就是说——<code>A,B,C</code>3个节点对外应当表现为一个整体，也就是集群<code>Cluster</code>。那么客户端该如何向<code>A,B,C</code>组成的集群写入数据？以下是笔者想到的实现方式：</p>
<ul>
<li>所有客户端均向<code>A,B,C</code>中某一节点（比如<code>A</code>）写入数据，由该节点将数据拷贝至其它节点以达到一致性。</li>
<li>向建立连接的节点写入数据，比如<code>客户端1</code>同<code>A</code>建立连接，<code>客户端1</code>向<code>A</code>写入数据，<code>客户端2</code>同<code>B</code>建立连接，<code>客户端2</code>向<code>B</code>写入数据，以此类推。</li>
</ul>
<p>读者是否觉得以上两种实现方式似曾相识——这和<strong><em>并发编程</em></strong>下的并发更改共享变量问题相似，由经验我们可知，我们最好是将对共享的操作<strong><em>串行，有序的</em></strong>执行。同样，如果多个客户端通过多个节点向集群写入数据，为了达到每个节点都有一份完整数据的目的，多个节点间会进行通讯，数据合并，而这其中又牵扯了数据的顺序等许多问题，工程实现起来比较复杂。<br>当然不是说不可以，笔者没见过这么做的~ ~）</p>
<p>方式一为目前流行的一致性解决思路，<code>Raft</code>协议采用了该思路，<code>Raft</code>协议解决了方式一面临的两大问题：</p>
<ul>
<li>集群启动（或者写入节点下线）时，如何选举出一个节点作为写入节点</li>
<li>写入节点如何与其它节点通讯，复制数据，保持数据在各节点的一致性</li>
</ul>
<p>以上两大问题便是<code>Raft</code>协议的两大功能：</p>
<ul>
<li><code>Leader Election</code></li>
<li><code>Log Replication</code></li>
</ul>
<p>分布式中任何环节都是不可靠的，实际问题比本人论述的复杂的多，但明确了上述问题，再去研究<code>Raft Paper</code>时，读者便可以快速掌握<code>Raft</code>协议。</p>
<p>建议大家观看<code>Raft</code>协议动画，简单明了生动：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://raft.github.io/raft.pdf" target="_blank" rel="external">Raft Pager</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/12/23/线段树应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/23/线段树应用/" itemprop="url">
                  线段树应用（编辑中）
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-23T02:25:15+08:00">
                2017-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习工作多年，逐渐悟得一名优秀的程序员应有的态度———<strong><em>优雅的解决问题</em></strong>。简而言之，解决问题并不是最终解，如何求得该问题的最优解才是一名优秀程序员应该考虑的问题。<code>360</code>同事对待问题的态度让我这种感觉愈发强烈。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>最近笔者在考虑如下一个需求：</p>
<blockquote>
<p>现有一集团，内部网络划分为N多个子网（N&gt;100），该N多个子网网段互相之间不交叉。有一批告警数据，该数据里携带了产生告警事件的设备<code>IPv4</code>地址，现笔者需要根据设备<code>IPv4</code>地址，将这些告警数据按子网网段分类。</p>
</blockquote>
<p>以上问题可抽象为：</p>
<p>问题Q：存在区间[1, 100]，该区间是由[1, 10], [11, 20], [21, 30]…[91, 100]等子区间组成，现给定一个正整数N（1 &lt;= N &lt;= 100），求解N落在那个子区间。 </p>
<blockquote>
<p>注解：将N多个子网网段用区间（由计算机网络可知<code>IPv4</code>地址为32位无符号整数）的形式表现，比如子网网段<code>10.95.12.0/24</code>表示的<code>IPv4</code>地址范围为：<code>10.95.12.0</code> ~ <code>10.95.12.255</code>（即：<code>0xa5f0c00</code>~<code>0xaf0cff</code>），其他网段类推，由此可见该需求属于我们问题Q的同一类问题。</p>
</blockquote>
<p>我们尝试去解决问题Q，首先比较容易想到，也是实现比较简单的便是<strong><em>遍历</em></strong>[1, 10], [11, 20]…[91, 100]等所有子区间，用N与子区间的左右端点作比较，确定N所在的子区间。显而易见，该方法简单明了，时间复杂度为O(n)。</p>
<p>子区间数目越多，遍历一次花费的代价就越大，在海量数据的处理中，这显然是不可忍受的。我们观察到子区间[1, 10], [11, 20], [21, 30]…[91, 100]是连续的，于是我们自然而然的想到了二分查找与二叉搜索树，不同的是以前我们接触的大多是单个节点的查找，现在是范围（即：子区间）的查找，由此今天的主角便登场了——线段树（又名区间树）。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/12/22/IOLoop简述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/22/IOLoop简述/" itemprop="url">
                  Tornado IOLoop图解
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-22T13:26:57+08:00">
                2017-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Tornado-IOLoop简述"><a href="#Tornado-IOLoop简述" class="headerlink" title="Tornado IOLoop简述"></a>Tornado IOLoop简述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者信奉这样一种哲学——“把书从薄读厚，然后从厚读薄”，<code>Tornado</code>源码犹如一部文学作品，汇集了众多优秀<code>Python</code>工程师的智慧结晶，奇思妙想让人拍手连连。一本好书每读一次，都有不同的感受，代码也是如此。为了能够在以后的工作学习中时时回顾品味一下，笔者决定将笔者对<code>Tornado</code>的理解以图记录下来。</p>
<p>在这里笔者推荐一款强大的在线绘图软件：<a href="https://www.draw.io/" target="_blank" rel="external">https://www.draw.io/</a>，想要<code>Visio</code>的专业，却不喜欢<code>Visio</code>笨重的读者绝对会让你好用到<code>Cry</code>。</p>
<h2 id="IOLoop图示"><a href="#IOLoop图示" class="headerlink" title="IOLoop图示"></a>IOLoop图示</h2><p><strong><em>注意：</em></strong> 对<code>IO</code>多路复用技术不了解的同学，可以先了解一下 <strong><em>阻塞/非阻塞，同步/异步，select，epoll</em></strong> 等概念。</p>
<p>笔者注意到，任何语言的事件循环（比如：<code>libev</code>，<code>nodejs</code>，…），最核心的<code>Feature</code>是相同的，不一样的只不过是实现方式，抽象层次不同，笔者将这些核心<code>Feature</code>总结如下：</p>
<ul>
<li>文件<code>IO</code>事件（比如：<code>socket</code>，<code>pipe</code>等<code>READ</code>，<code>WRITE</code>，<code>HUP</code>事件 …）</li>
<li>系统信号(比如：<code>SIGINT</code>,<code>SIGHUP</code>…)</li>
<li>定时器</li>
</ul>
<p><code>Tornado IOLoop</code>的实现也不例外，如下图所示：</p>
<p><img src="/2017/12/22/IOLoop简述/ioloop.jpg" alt="IOLoop示意图"></p>
<h2 id="IOLoop代码随笔"><a href="#IOLoop代码随笔" class="headerlink" title="IOLoop代码随笔"></a>IOLoop代码随笔</h2><p>以下是笔者对<code>IOLoop</code>核心方法<code>start</code>的源码注解，可以用于结合图示，加深理解。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">if</span> self._running:</div><div class="line">        <span class="comment"># IOLoop已经启动。</span></div><div class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"IOLoop is already running"</span>)</div><div class="line">    self._setup_logging()  <span class="comment"># 开始安装日志模块。</span></div><div class="line">    <span class="keyword">if</span> self._stopped:</div><div class="line">        self._stopped = <span class="keyword">False</span>  <span class="comment"># 如果已经停止，则直接返回。</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="comment"># 获取当前线程的IOLoop实例。</span></div><div class="line">    old_current = getattr(IOLoop._current, <span class="string">"instance"</span>, <span class="keyword">None</span>)</div><div class="line">    IOLoop._current.instance = self  <span class="comment"># 将当前IOLoop实例置为self。</span></div><div class="line">    self._thread_ident = thread.get_ident()  <span class="comment"># 线程id。</span></div><div class="line">    self._running = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="comment"># signal.set_wakeup_fd closes a race condition in event loops:</span></div><div class="line">    <span class="comment"># a signal may arrive at the beginning of select/poll/etc</span></div><div class="line">    <span class="comment"># before it goes into its interruptible sleep, so the signal</span></div><div class="line">    <span class="comment"># will be consumed without waking the select.  The solution is</span></div><div class="line">    <span class="comment"># for the (C, synchronous) signal handler to write to a pipe,</span></div><div class="line">    <span class="comment"># which will then be seen by select.</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># In python's signal handling semantics, this only matters on the</span></div><div class="line">    <span class="comment"># main thread (fortunately, set_wakeup_fd only works on the main</span></div><div class="line">    <span class="comment"># thread and will raise a ValueError otherwise).</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># If someone has already set a wakeup fd, we don't want to</span></div><div class="line">    <span class="comment"># disturb it.  This is an issue for twisted, which does its</span></div><div class="line">    <span class="comment"># SIGCHLD processing in response to its own wakeup fd being</span></div><div class="line">    <span class="comment"># written to.  As long as the wakeup fd is registered on the IOLoop,</span></div><div class="line">    <span class="comment"># the loop will still wake up and everything should work.</span></div><div class="line"></div><div class="line">    <span class="comment"># wakeup_fd是用来唤醒主事件循环（信号唤醒，或者从别的线程唤醒主线程）。</span></div><div class="line">    old_wakeup_fd = <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> hasattr(signal, <span class="string">'set_wakeup_fd'</span>) <span class="keyword">and</span> os.name == <span class="string">'posix'</span>:</div><div class="line">        <span class="comment"># requires python 2.6+, unix.  set_wakeup_fd exists but crashes</span></div><div class="line">        <span class="comment"># the python process on windows.</span></div><div class="line"></div><div class="line">        <span class="comment"># Python2.6版本以上，Unix-like系统中，signal模块支持set_wakeup_fd方法。</span></div><div class="line">        <span class="comment"># Windows上siganl存在该方法，但是会crash。</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())</div><div class="line">            <span class="keyword">if</span> old_wakeup_fd != <span class="number">-1</span>:</div><div class="line">                <span class="comment"># Already set, restore previous value.  This is a little racy,</span></div><div class="line">                <span class="comment"># but there's no clean get_wakeup_fd and in real use the</span></div><div class="line">                <span class="comment"># IOLoop is just started once at the beginning.</span></div><div class="line">                signal.set_wakeup_fd(old_wakeup_fd)</div><div class="line">                old_wakeup_fd = <span class="keyword">None</span></div><div class="line">        <span class="keyword">except</span> ValueError:</div><div class="line">            <span class="comment"># Non-main thread, or the previous value of wakeup_fd</span></div><div class="line">            <span class="comment"># is no longer valid.</span></div><div class="line">            <span class="comment"># 参考signal的官方手册，set_wakeup_fd仅可在主线程中调用。</span></div><div class="line">            old_wakeup_fd = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="comment"># Prevent IO event starvation by delaying new callbacks</span></div><div class="line">            <span class="comment"># to the next iteration of the event loop.</span></div><div class="line">            <span class="comment"># ncallbacks记录了此次循环的回调函数个数，新增加的回调函数将要在下次循环被调用。</span></div><div class="line">            ncallbacks = len(self._callbacks)</div><div class="line"></div><div class="line">            <span class="comment"># Add any timeouts that have come due to the callback list.</span></div><div class="line">            <span class="comment"># Do not run anything until we have determined which ones</span></div><div class="line">            <span class="comment"># are ready, so timeouts that call add_timeout cannot</span></div><div class="line">            <span class="comment"># schedule anything in this iteration.</span></div><div class="line">            due_timeouts = []  <span class="comment"># 即将超时的任务。</span></div><div class="line">            <span class="keyword">if</span> self._timeouts:</div><div class="line">                now = self.time()</div><div class="line">                <span class="keyword">while</span> self._timeouts:</div><div class="line">                    <span class="keyword">if</span> self._timeouts[<span class="number">0</span>].callback <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                        <span class="comment"># The timeout was cancelled.  Note that the</span></div><div class="line">                        <span class="comment"># cancellation check is repeated below for timeouts</span></div><div class="line">                        <span class="comment"># that are cancelled by another timeout or callback.</span></div><div class="line">                        heapq.heappop(self._timeouts)</div><div class="line">                        self._cancellations -= <span class="number">1</span></div><div class="line">                    <span class="keyword">elif</span> self._timeouts[<span class="number">0</span>].deadline &lt;= now:</div><div class="line">                        due_timeouts.append(heapq.heappop(self._timeouts))</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="keyword">break</span></div><div class="line">                <span class="keyword">if</span> (self._cancellations &gt; <span class="number">512</span> <span class="keyword">and</span></div><div class="line">                        self._cancellations &gt; (len(self._timeouts) &gt;&gt; <span class="number">1</span>)):</div><div class="line">                    <span class="comment"># Clean up the timeout queue when it gets large and it's</span></div><div class="line">                    <span class="comment"># more than half cancellations.</span></div><div class="line">                    <span class="comment"># 如果定时任务取消数量大于512，并且超过总定时任务的半数，则清理self._timeouts，并重新平衡堆。</span></div><div class="line">                    self._cancellations = <span class="number">0</span></div><div class="line">                    self._timeouts = [x <span class="keyword">for</span> x <span class="keyword">in</span> self._timeouts</div><div class="line">                                      <span class="keyword">if</span> x.callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>]</div><div class="line">                    heapq.heapify(self._timeouts)</div><div class="line"></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(ncallbacks):</div><div class="line">                <span class="comment"># 执行回调函数。</span></div><div class="line">                self._run_callback(self._callbacks.popleft())</div><div class="line">            <span class="keyword">for</span> timeout <span class="keyword">in</span> due_timeouts:</div><div class="line">                <span class="comment"># 执行定时任务。</span></div><div class="line">                <span class="keyword">if</span> timeout.callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    self._run_callback(timeout.callback)</div><div class="line">            <span class="comment"># Closures may be holding on to a lot of memory, so allow</span></div><div class="line">            <span class="comment"># them to be freed before we go into our poll wait.</span></div><div class="line">            due_timeouts = timeout = <span class="keyword">None</span>  <span class="comment"># 防止内存泄漏</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> self._callbacks:</div><div class="line">                <span class="comment"># If any callbacks or timeouts called add_callback,</span></div><div class="line">                <span class="comment"># we don't want to wait in poll() before we run them.</span></div><div class="line">                <span class="comment"># 如果发现新增的_callbacks，（回调函数执行时加入了新的回调函数）。</span></div><div class="line">                poll_timeout = <span class="number">0.0</span></div><div class="line">            <span class="keyword">elif</span> self._timeouts:</div><div class="line">                <span class="comment"># If there are any timeouts, schedule the first one.</span></div><div class="line">                <span class="comment"># Use self.time() instead of 'now' to account for time</span></div><div class="line">                <span class="comment"># spent running callbacks.</span></div><div class="line">                poll_timeout = self._timeouts[<span class="number">0</span>].deadline - self.time()  <span class="comment"># 距离将来最近一次定时任务的时间，wait该时间。</span></div><div class="line">                poll_timeout = max(<span class="number">0</span>, min(poll_timeout, _POLL_TIMEOUT))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="comment"># No timeouts and no callbacks, so use the default.</span></div><div class="line">                <span class="comment"># 未发现新的回调函数与定时任务，则调用poll，等待IO事件，超时事件为3600秒。</span></div><div class="line">                poll_timeout = _POLL_TIMEOUT</div><div class="line"></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._running:</div><div class="line">                <span class="comment"># 如果回调函数中有调用stop的则，跳出事件循环。</span></div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                <span class="comment"># clear alarm so it doesn't fire while poll is waiting for</span></div><div class="line">                <span class="comment"># events.</span></div><div class="line">                signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="comment"># 等待IO事件，events_pairs内容为：[(fd, events), (fd, events), ]</span></div><div class="line">                event_pairs = self._impl.poll(poll_timeout)</div><div class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">                <span class="comment"># Depending on python version and IOLoop implementation,</span></div><div class="line">                <span class="comment"># different exception types may be thrown and there are</span></div><div class="line">                <span class="comment"># two ways EINTR might be signaled:</span></div><div class="line">                <span class="comment"># * e.errno == errno.EINTR</span></div><div class="line">                <span class="comment"># * e.args is like (errno.EINTR, 'Interrupted system call')</span></div><div class="line"></div><div class="line">                <span class="comment"># poll陷入内核态以后，进程捕获到的信号会导致poll wait结束，并且错误码为EINTR。</span></div><div class="line">                <span class="keyword">if</span> errno_from_exception(e) == errno.EINTR:</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">raise</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                signal.setitimer(signal.ITIMER_REAL,</div><div class="line">                                 self._blocking_signal_threshold, <span class="number">0</span>)</div><div class="line"></div><div class="line">            <span class="comment"># Pop one fd at a time from the set of pending fds and run</span></div><div class="line">            <span class="comment"># its handler. Since that handler may perform actions on</span></div><div class="line">            <span class="comment"># other file descriptors, there may be reentrant calls to</span></div><div class="line">            <span class="comment"># this IOLoop that modify self._events</span></div><div class="line">            self._events.update(event_pairs)</div><div class="line">            <span class="keyword">while</span> self._events:</div><div class="line">                fd, events = self._events.popitem()</div><div class="line">                <span class="keyword">try</span>:</div><div class="line">                    <span class="comment"># 获取file-like object，与IO事件的处理函数handler。</span></div><div class="line">                    fd_obj, handler_func = self._handlers[fd]</div><div class="line">                    <span class="comment"># 调用handler，处理fd_obj上发生的events事件，</span></div><div class="line">                    <span class="comment"># handler_func在add_handler时候，加入了对事件处理的wraps。</span></div><div class="line">                    handler_func(fd_obj, events)</div><div class="line">                <span class="keyword">except</span> (OSError, IOError) <span class="keyword">as</span> e:</div><div class="line">                    <span class="keyword">if</span> errno_from_exception(e) == errno.EPIPE:</div><div class="line">                        <span class="comment"># Happens when the client closes the connection</span></div><div class="line">                        <span class="comment"># 客户端关闭了同服务器的连接。</span></div><div class="line">                        <span class="keyword">pass</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="comment"># 处理异常。</span></div><div class="line">                        self.handle_callback_exception(self._handlers.get(fd))</div><div class="line">                <span class="keyword">except</span> Exception:</div><div class="line">                    self.handle_callback_exception(self._handlers.get(fd))</div><div class="line">            fd_obj = handler_func = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="comment"># reset the stopped flag so another start/stop pair can be issued</span></div><div class="line">        self._stopped = <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">        <span class="comment"># 还原前一个IOLoop实例（作者也说了这种情况基本没有...）</span></div><div class="line">        IOLoop._current.instance = old_current</div><div class="line">        <span class="keyword">if</span> old_wakeup_fd <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            signal.set_wakeup_fd(old_wakeup_fd)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/11/13/Python内存回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/13/Python内存回收机制/" itemprop="url">
                  Python内存回收机制
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-13T23:28:54+08:00">
                2017-11-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python2-7内存回收机制-一"><a href="#Python2-7内存回收机制-一" class="headerlink" title="Python2.7内存回收机制(一)"></a>Python2.7内存回收机制(一)</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><code>Python</code>的内存回收采用<em>引用计数</em>机制。引用计数是一种简单而广泛使用的资源回收机制，例如<code>Linux</code>平台的<em>文件描述符</em>，<code>Windows</code>平台下的<em>内核对象</em>等均采用引用计数的方式进行管理。本文将结合<code>Python2.7</code>官方手册阐明<code>Python2.7</code>的<em>引用计数机制</em>（如无特殊说明，本文所提及的<code>Python</code>均为<code>CPython</code>）。</p>
<p><code>Python</code>语言在设计之初就是一门面向对象的语言，即一切皆为对象，在<code>Python</code>官方介绍通用对象结构<a href="https://docs.python.org/2/c-api/structures.html#c.PyObject" target="_blank" rel="external"><code>Common Object Structures</code></a>一文中，有这样一段话：</p>
<blockquote>
<p>All Python objects ultimately share a small number of fields at the beginning of the object’s representation in memory. These are represented by the<a href="https://docs.python.org/2/c-api/structures.html#c.PyObject" target="_blank" rel="external"><code>PyObject</code></a> and <a href="https://docs.python.org/2/c-api/structures.html#c.PyVarObject" target="_blank" rel="external"><code>PyVarObject</code></a> types, which are defined, in turn, by the expansions of some macros also used, whether directly or indirectly, in the definition of all other Python objects.</p>
</blockquote>
<p>简单来说，<code>Python</code>中所有对象的开始位置，都有一组成员变量，以<code>C</code>语言的两个自定义类型——<code>PyObject</code>与<code>PyVarObject</code>来表示（有兴趣的，可以通读<code>Common Object Structures</code>一文，或者参考《<code>Python源代码剖析</code>》一书，这里不做具体阐述)，<code>PyObject</code>与<code>PyVarObject</code>的开始位置都有一组相同的成员变量（分别由宏<code>PyObject_HEAD</code>，<code>PyObject_HEAD</code>扩展）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Py_ssize_t ob_refcnt;  <span class="comment">// 对象引用计数</span></div><div class="line">PyTypeObject *ob_type;  <span class="comment">// 指向对象类型结构体的指针（与本文无关不做具体阐述）</span></div></pre></td></tr></table></figure>
<p>由此可见，在<code>CPython</code>实现中，每个<code>Python</code>对象均有一个名为<code>ob_refcnt</code>的成员变量用于标识该对象的引用计数。而众所周知，在<code>Python</code>的实现中，变量只是保存了一个对象的引用（即指针），而非对象本身，所以每当一个<code>Python</code>对象被一个不同变量所引用时，对象的引用计数就会+1，相反当变量不再引用该对象时，该对象的引用计数就会-1，当对象的引用计数变为0时，该对象就会在未来的某个时间被<code>Python</code>的垃圾回收器所回收。</p>
<p>通过<code>Python</code>的<code>sys</code>模块的<code>getrefcount</code>方法可以获取<code>Python</code>对象的当前引用计数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">        a = A()</div><div class="line">     b = c = a</div><div class="line">     print(sys.getrefcount(a))</div></pre></td></tr></table></figure>
<pre><code>示例运行结果为4，比实际引用数量（a, b, c）多1，那么为什么会这样呢，`sys.getrefcount`的文档作出了说明：

&gt;Return the reference count of the *object*. The count returned is generally one higher than you might expect, because it includes the (temporary) reference as an argument to [`getrefcount()`](https://docs.python.org/2.7/library/sys.html#sys.getrefcount).

把对象当做参数调用`sys.getrefcount`方法会增加对象的一个临时引用计数。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/08/31/Huffman编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/31/Huffman编码/" itemprop="url">
                  Huffman编码
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-31T00:45:00+08:00">
                2017-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Alg/" itemprop="url" rel="index">
                    <span itemprop="name">Alg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h1><p><strong>注意：</strong> <a href="">原创技术博客，转载请注明原文地址</a>。</p>
<h2 id="Huffman编码简介"><a href="#Huffman编码简介" class="headerlink" title="Huffman编码简介"></a>Huffman编码简介</h2><p>依然记得初次接触<code>Huffman</code>编码，是在大一的《计算机组成原理》课程上，老师采用<code>Huffman</code>编码实现了一种<code>CPU</code>（虚拟机字节码同理）变长指令集。当时感觉特别神奇，后来又在《数据结构》课程上接触到了<code>Huffman Tree</code>（霍夫曼树），算是对<code>Huffman</code>编码有了一个比较全面的认识。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="string">"""Huffman编码Python实现。"""</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, score, value=None, lchild=None, rchild=None)</span>:</span></div><div class="line">        self.score = score</div><div class="line">        self.value = value</div><div class="line">        self.lchild = lchild</div><div class="line">        self.rchild = rchild</div><div class="line">        self.bit = <span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_huffman_tree</span><span class="params">(sequence)</span>:</span></div><div class="line"></div><div class="line">    char2frequency = dict()</div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> sequence:</div><div class="line">        char2frequency.setdefault(c, <span class="number">0</span>)</div><div class="line">        char2frequency[c] += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_cmp</span><span class="params">(a, b)</span>:</span></div><div class="line">        delta = a.score - b.score</div><div class="line">        <span class="keyword">if</span> delta != <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> sequence.index(a.value) - sequence.index(b.value)</div><div class="line">        <span class="keyword">return</span> delta</div><div class="line"></div><div class="line">    queue = [Node(char2frequency[x], x) <span class="keyword">for</span> x <span class="keyword">in</span> set(sequence)]</div><div class="line">    queue.sort(cmp=_cmp)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> len(queue) &gt; <span class="number">1</span>:</div><div class="line">        lchild, rchild = queue.pop(), queue.pop()</div><div class="line">        lchild.bit, rchild.bit = <span class="number">0</span>, <span class="number">1</span></div><div class="line">        parent_node = Node(</div><div class="line">            lchild.score+rchild.score, lchild=lchild, rchild=rchild)</div><div class="line">        queue.insert(<span class="number">0</span>, parent_node)</div><div class="line">        queue.sort(key=<span class="keyword">lambda</span> o: o.score)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> queue[<span class="number">0</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_check_list</span><span class="params">(node)</span>:</span></div><div class="line"></div><div class="line">    stack = []</div><div class="line">    check_list = dict()</div><div class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">or</span> stack:</div><div class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            stack.append(node)</div><div class="line">            node = node.lchild</div><div class="line">        <span class="keyword">if</span> stack:</div><div class="line">            node = stack.pop()</div><div class="line">            <span class="keyword">if</span> node.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                sequence = [x.bit <span class="keyword">for</span> x <span class="keyword">in</span> stack]</div><div class="line">                sequence.append(node.bit)</div><div class="line">                check_list[node.value] = int(<span class="string">''</span>.join(map(str, sequence)), <span class="number">2</span>)</div><div class="line">            node = node.rchild</div><div class="line">    <span class="keyword">return</span> check_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    tree = generate_huffman_tree(<span class="string">'shootsheetjobwork'</span>)</div><div class="line">    check_list = generate_check_list(tree)</div><div class="line">    <span class="keyword">print</span> check_list</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/07/31/MySQL前缀索引/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/31/MySQL前缀索引/" itemprop="url">
                  MySQL前缀索引
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-31T22:42:18+08:00">
                2017-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index">
                    <span itemprop="name">MySQL</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/Index/" itemprop="url" rel="index">
                    <span itemprop="name">Index</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="MySQL前缀索引"><a href="#MySQL前缀索引" class="headerlink" title="MySQL前缀索引"></a>MySQL前缀索引</h2><p><strong>注意：</strong> 本文的所有优化仅针对InnoDB存储引擎。</p>
<p>MySQL索引可以加快查询速度，但是索引并不是越多越好，索引虽然可以加快数据的查询速度，但是索引文件本身需要占用存储空间，数据的插入，删除，和修改也需要索引保持同步，据一线有经验的DBA介绍，索引列占表所有列的30%是比较合理的。</p>
<h4 id="查看表存在的索引"><a href="#查看表存在的索引" class="headerlink" title="查看表存在的索引"></a>查看表存在的索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> <span class="string">`table`</span>;</div></pre></td></tr></table></figure>
<h4 id="查看索引占用磁盘空间大小"><a href="#查看索引占用磁盘空间大小" class="headerlink" title="查看索引占用磁盘空间大小"></a>查看索引占用磁盘空间大小</h4><blockquote>
<p>MySQL<code>information_schema</code>数据库<code>TABLES</code>表<a href="https://dev.mysql.com/doc/refman/5.7/en/tables-table.html" target="_blank" rel="external">官方手册</a></p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">sum</span>(INDEX_LENGTH/(<span class="number">1024</span>*<span class="number">1024</span>)), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">as</span> <span class="string">'Total Index Size'</span> <span class="keyword">from</span> <span class="string">`information_schema`</span>.<span class="string">`TABLES`</span> <span class="keyword">where</span> <span class="string">`table_schema`</span> = <span class="string">'order'</span> <span class="keyword">and</span> <span class="string">`table_name`</span> = <span class="string">'order_base'</span>;</div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 以下两种情况，不建议建立索引。</p>
<ul>
<li>表记录数比较少 —— InnoDB辅助索引叶子节点存储的不是记录的物理地址，而是主键值，使用辅助索引查找数据总是需要第二次查找主键索引，在表记录较少的情况下，建立索引反而会降低查询性能，所以直接全表扫描就好了，具体基准需根据业务场景而定。</li>
<li>索引的选择性比较低 —— 索引的选择性指不重复的索引值与表记录数的比值，值域为(0, 1]。索引选择性越高越好，可以通俗的理解为，选择性高的索引在查询时往往可以筛选出比较多的记录，所以访问表的次数较少，索引的有效率比较高。例如存在基本表<code>table</code>，我们要在表<code>table</code>的<code>column</code>列上建立一个索引，我们使用如下<code>SQL</code>语句计算该索引的选择性：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="string">`column`</span>) / <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> <span class="string">`table`</span>;</div></pre></td></tr></table></figure>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引是一种与索引选择性相关联的索引优化技术，顾名思义，使用列的前缀代替整个列作为Key，当前缀长度合理时，既可以做到前缀索引的选择性接近全列索引，同时因为索引Key变短而减少索引文件的大小和维护开销。</p>
<p>想象一下存在如下业务场景，一张存放订单信息的基本表<code>order</code>，订单号长度为24位（如：61700123215824），表结构如下：</p>
<table>
<thead>
<tr>
<th>id</th>
<th>order_id</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>61700123215824</td>
</tr>
<tr>
<td>2</td>
<td>61500280698102</td>
</tr>
<tr>
<td>3</td>
<td>61500280756582</td>
</tr>
</tbody>
</table>
<p>首先计算一下，全列索引选择性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="string">`order_id`</span>) / <span class="keyword">count</span>(*), <span class="number">2</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</div></pre></td></tr></table></figure>
<p>结果为1.00，选择前缀长度为5，看一下索引的选择性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="string">`order_id`</span>, <span class="number">5</span>)) / <span class="keyword">count</span>(*), <span class="number">2</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</div></pre></td></tr></table></figure>
<p>结果为0.00，5个字符长度的前缀，看来不行，我们增加到10，看一下索引的选择性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="string">`order_id`</span>, <span class="number">10</span>)) / <span class="keyword">count</span>(*), <span class="number">2</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</div></pre></td></tr></table></figure>
<p>结果为0.63，差强人意，我们继续以5位单位递增，看一下索引的选择性：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="string">`order_id`</span>, <span class="number">15</span>)) / <span class="keyword">count</span>(*), <span class="number">2</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</div></pre></td></tr></table></figure>
<p>由于round的四舍五入，结果为1.00，那前缀能不能更少一些，在公司的业务系统内试了一下，前缀长度为11时，索引选择性为0.9999，四舍五入为1。通过夹逼的方法（😆默默的想起高数的夹逼定理），找到了最佳的索引前缀长度为11，接下来我们创建前缀索引：</p>
<blockquote>
<p>创建前缀索引</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">`order`</span> <span class="keyword">add</span> <span class="keyword">index</span> <span class="string">`idx_order_id`</span>(<span class="string">`order_id`</span>(<span class="number">11</span>));</div></pre></td></tr></table></figure>
<p><strong>注意：</strong> 前缀索引的缺点</p>
<ul>
<li>前缀索引不能用于order by与group by操作。</li>
<li>前缀索引不能用于covering index —— 显而易见，前缀索引并未包含<code>order_id</code>列的全部信息，所以并不能用于covering index。</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/07/06/高效率Shell/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/06/高效率Shell/" itemprop="url">
                  高效率Shell
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-06T13:52:12+08:00">
                2017-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Bash/" itemprop="url" rel="index">
                    <span itemprop="name">Bash</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Bash/Shell/" itemprop="url" rel="index">
                    <span itemprop="name">Shell</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>快速将开发分支代码合并至测试分支。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> DEV=dev</div></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">merge_dev</span></span>() &#123;</div><div class="line">    <span class="keyword">if</span> [ -z <span class="variable">$&#123;DEV&#125;</span> ]; <span class="keyword">then</span></div><div class="line">        <span class="keyword">if</span> [ -z <span class="variable">$1</span> ]; <span class="keyword">then</span></div><div class="line">            DEV=<span class="string">"dev"</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            DEV=<span class="variable">$1</span></div><div class="line">        <span class="keyword">fi</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">    BRANCH=$(git rev-parse --abbrev-ref HEAD)</div><div class="line">    git push origin <span class="variable">$&#123;BRANCH&#125;</span></div><div class="line">    git checkout <span class="variable">$&#123;DEV&#125;</span> \</div><div class="line">        &amp;&amp; git pull origin <span class="variable">$&#123;DEV&#125;</span> \</div><div class="line">        &amp;&amp; git merge <span class="variable">$&#123;BRANCH&#125;</span> -m <span class="string">"merge code automatically"</span> \</div><div class="line">        &amp;&amp; git push origin <span class="variable">$&#123;DEV&#125;</span> \</div><div class="line">        &amp;&amp; git checkout <span class="variable">$&#123;BRANCH&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>统计工程代码行数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ./ -name <span class="string">"*.py"</span> -exec wc <span class="_">-l</span> &#123;&#125; \;|awk <span class="string">'BEGIN&#123;total=0&#125;&#123;print $1"\t"$2; $total+=$1&#125;END&#123;print "total lines: "$total&#125;'</span></div></pre></td></tr></table></figure>
<p>显示代码行最多的文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ./ -name <span class="string">"*.py"</span> | xargs -n 1 wc <span class="_">-l</span>|sort -nr</div></pre></td></tr></table></figure>
<p>显示处于<code>TIME_WAIT</code>的<code>SOCKET</code>个数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -n|awk <span class="string">'/^tcp/&#123;a[$6]++&#125;END&#123;for (j in a) print a[j], j&#125;'</span>|sort -nr|head -n 10</div></pre></td></tr></table></figure>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Gatsby" />
          <p class="site-author-name" itemprop="name">Gatsby</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">17</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">10</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gatsby</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
