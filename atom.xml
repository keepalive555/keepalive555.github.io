<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>枫叶居</title>
  
  <subtitle>桃李春风一杯酒，江湖夜雨十年灯</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.nice-ai-life.com/"/>
  <updated>2018-05-30T15:09:08.276Z</updated>
  <id>https://blog.nice-ai-life.com/</id>
  
  <author>
    <name>Gatsby</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>高并发场景缓存常见问题（编辑中）</title>
    <link href="https://blog.nice-ai-life.com/2018/05/28/%E9%AB%98%E5%B9%B6%E5%8F%91%E5%9C%BA%E6%99%AF%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.nice-ai-life.com/2018/05/28/高并发场景缓存常见问题/</id>
    <published>2018-05-28T14:30:13.000Z</published>
    <updated>2018-05-30T15:09:08.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>缓存——是一种后台开发中常见的技术，常用于解决由外存储器读取速率较低引起的性能问题。在开发工作中，我们经常会将<code>Redis</code>用作缓存系统（在非严格条件下，<code>Redis</code>的单机<code>QPS|TPS</code>可高达<code>15w</code>左右，读者可使用<code>redis-benchmark</code>命令验证），如无特殊说明，本文以下所引用的<code>缓存系统</code>均是指后台缓存系统。</p><p>缓存系统的核心宗旨：<strong><em>减小后端 数据库/下游业务/… 负载。</em></strong></p><h2 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h2><ul><li><code>Cache Aside</code></li><li><code>Read-Through Caching</code></li><li><code>Write-Through Caching</code></li><li><code>Write-Behind Caching</code></li></ul><p>在此不再赘述，感兴趣的读者可参考：<a href="https://vladmihalcea.com/a-beginners-guide-to-cache-synchronization-strategies/" target="_blank" rel="external">A beginner’s guide to Cache synchronization strategies</a></p><p>后端开发实践中，常见的缓存更新策略有三种：</p><ol><li>读数据库并更新缓存</li><li>更新数据库同时更新缓存</li><li>更新数据</li></ol><h2 id="缓存更新问题"><a href="#缓存更新问题" class="headerlink" title="缓存更新问题"></a>缓存更新问题</h2><p>在工程实践中，缓存系统特别适合<strong><em><code>高并发读</code></em></strong>的业务场景（在接下来的章节，笔者会对<code>高并发写</code>业务场景下的优化铺开陈述）。反过来，<code>高并发读</code>的业务场景同时也是一面放大镜，会将缓存系统的一些“小问题放大。</p><p>典型的缓存更新代码如下所示：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span><span class="params">($useCache=true)</span> </span>&#123;</div><div class="line"><span class="comment">// $useCache为true，表示从缓存中读取</span></div><div class="line"><span class="keyword">if</span> ($useCache) &#123;</div><div class="line"><span class="comment">// redis缓存key</span></div><div class="line">$cacheKey = <span class="string">'cache_key'</span>;</div><div class="line">$cache = $redis.get($cacheKey)</div><div class="line"><span class="keyword">if</span> ($cache) &#123;</div><div class="line"><span class="comment">// json_decode数据</span></div><div class="line">$data = json_decode($cache, $assoc=<span class="keyword">true</span>);</div><div class="line"><span class="keyword">return</span> $data;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 未命中缓存，则从数据库中取数据</span></div><div class="line">$data = $db-&gt;select(<span class="string">'select *from tbl_data'</span>);</div><div class="line"><span class="keyword">if</span> ($useCache &amp;&amp; $data) &#123;</div><div class="line"><span class="comment">// 从数据库读取成功，设置缓存</span></div><div class="line">$redis.set($cacheKey, json_encode($data), <span class="number">300</span>);</div><div class="line">&#125;</div><div class="line"><span class="keyword">return</span> $data;</div><div class="line">&#125;</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>示例代码中，程序会首先尝试从<code>Redis</code>缓存中读取数据，如果命中则直接返回缓存的数据，如果未命中则会查询数据库，并更新缓存。假设程序从<code>Redis</code>缓存中读取的数据为<code>&quot;&quot;</code>，<strong><em>程序无法判断是读取缓存失败，还是从缓存中读取的数据为<code>&quot;&quot;</code>（两种情况均返回<code>&quot;&quot;</code>）</em></strong>，所以在数据为<code>&quot;&quot;</code>的情况下，即使程序命中<code>Redis</code>缓存，程序依然需要从数据库中取一次数据，这便是——<strong><em>缓存击穿</em></strong>，在<code>高并发读</code>的业务场景下，很多请求依然会打到后端数据库，显然这有违<code>缓存系统</code>的宗旨。</p><p>要解决<strong><em>缓存击穿</em></strong>问题，需提供一种可以区别<code>&quot;&quot;</code>为命中缓存还是未命中缓存的方法。可以想到的方法很多，这里提供两种方法仅做参考：</p><h4 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h4><p>布隆过滤器，英文名<code>Bloom Filter</code>，详细资料可参考 <a href="http://blog.nice-ai-life.com/2018/02/03/bloom-filter/">上篇博文</a>，此处不做赘述。在很多浏览器的设计实现中，<code>布隆过滤器</code>用于快速判断一个<code>URL</code>（代表的资源）是否命中本地缓存。如果“是”，则浏览器在本地缓存获取<code>URL</code>标识的资源，若获取失败（<code>布隆过滤器</code>发生误判），则请求该<code>URL</code>获取资源。</p><p>受此启发，在以上示例程序中，我们可引入<code>布隆过滤器</code>。</p><h4 id="添加辅助字段"><a href="#添加辅助字段" class="headerlink" title="添加辅助字段"></a>添加辅助字段</h4><p>此方法简单实用，我们仅需对数据进行一次<code>Wrap</code>即可，示例代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 更新缓存</span></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$cacheKey = <span class="string">'cache_key'</span>;</div><div class="line">$data = $db-&gt;select(<span class="string">'select *from tbl_data'</span>);</div><div class="line">$cacheData = <span class="keyword">array</span>(</div><div class="line"><span class="string">'hit'</span>: <span class="keyword">true</span>,</div><div class="line"><span class="string">'data'</span> =&gt; $data,</div><div class="line">);</div><div class="line">$redis.set($cacheKey, json_encode($cacheData), <span class="number">300</span>);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">// 获取缓存</span></div><div class="line">$cacheKey = <span class="string">'cache_key'</span>;</div><div class="line">$data = $redis.get($cacheKey);</div><div class="line">$data = json_encode($data, $assoc=<span class="keyword">true</span>);</div><div class="line"><span class="keyword">if</span> ($data &amp;&amp; $data[<span class="string">'hit'</span>]) &#123;</div><div class="line"><span class="keyword">return</span> $data[<span class="string">'data'</span>];</div><div class="line">&#125;</div><div class="line"><span class="comment">// 读取数据库...</span></div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure><p>我们引入了<code>hit</code>辅助字段，用于判断是读取缓存失败，还是从缓存中读取的数据为<code>&quot;&quot;</code>。</p><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>未完待续…</p><h3 id="缓存失效"><a href="#缓存失效" class="headerlink" title="缓存失效"></a>缓存失效</h3><p>未完待续…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;缓存——是一种后台开发中常见的技术，常用于解决由外存储器读取速率较低引起的性能问题。在开发工作中，我们经常会将&lt;code&gt;Redis&lt;/co
      
    
    </summary>
    
      <category term="系统架构" scheme="https://blog.nice-ai-life.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="系统架构" scheme="https://blog.nice-ai-life.com/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
      <category term="缓存击穿" scheme="https://blog.nice-ai-life.com/tags/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF/"/>
    
      <category term="缓存雪崩" scheme="https://blog.nice-ai-life.com/tags/%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/"/>
    
      <category term="缓存失效" scheme="https://blog.nice-ai-life.com/tags/%E7%BC%93%E5%AD%98%E5%A4%B1%E6%95%88/"/>
    
  </entry>
  
  <entry>
    <title>bloom filter（布隆过滤器）</title>
    <link href="https://blog.nice-ai-life.com/2018/02/03/bloom-filter/"/>
    <id>https://blog.nice-ai-life.com/2018/02/03/bloom-filter/</id>
    <published>2018-02-02T16:21:14.000Z</published>
    <updated>2018-05-28T13:38:57.196Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在互联网后台的开发工作中，笔者会经常遇到各种各样的<strong><em>白名单</em></strong>业务场景，比如以下典型场景：</p><ol><li>现有1亿个用户<code>user_id</code>，如何快速判断一个<code>user_id</code>是否在该白名单内</li><li>网络爬虫解析出一个页面的<code>url</code>清单，如何快速判断该<code>url</code>是否已经被抓取过</li><li>现有1亿个<code>user_id</code>，如何快速判断哪些<code>user_id</code>曾重复出现</li><li>服务器收到来自某个<code>ip</code>地址的请求，快速判断该<code>ip</code>地址是否在黑名单</li><li>……</li></ol><p>熟悉数据结构的读者，略微思考一下，便知以上若干问题的核心需求是：<strong><em>设计一个内存占用少且又高效的查找算法/数据结构。</em></strong> 以场景1为例，大多数读者首先想到的数据结构为<strong><em>哈希表</em></strong>，任意元素均可在<code>O(1)</code>时间复杂度内快速完成查找。</p><p>假设哈希表的装载因子为0.5（实践中比较常见的取值），粗略计算一下1亿个int类型<code>user_id</code>的内存占用约为<code>745MB</code>，一个白名单要占用如此多的内存空间，这显然是不可接受的。那么我们如何既能达成我们的目的，又占用比较小的内存呢？</p><p>一个<code>user_id</code>是否在白名单之内，只可能存在两种取值——是/否，从<strong><em>香农信息论</em></strong> 角度来看，使用1个<code>bit</code>即可表示是/否两种取值。一个<code>int</code>类型变量可存储<code>2^32</code>种取值，而当前业务场景下我们仅仅需要<code>0</code>和<code>1</code>两种状态便可（存储4种状态使用2个<code>bit</code>，存储8种状态使用3个<code>bit</code>，以此类推…）。存储1亿个<code>bit</code>占用空间约为<code>11MB</code>，大大减少了内存占用，这便是<code>Bitmap</code>数据结构。</p><h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p><code>Bitmap</code>是一种紧凑的数据结构。以场景1为例，首先在内存中连续分配1亿个<code>bit</code>，要判断<code>user_id</code>为<code>1000</code>的用户是否在白名单之内，只需获取<code>bit</code>序列的第<code>1000</code>位<code>bit</code>的状态（1：<code>user_id</code>在白名单，0：<code>user_id</code>不在白名单）。如下为<code>c</code>语言版本的示例代码（也可查看笔者的<a href="https://github.com/keepalive555/study/blob/master/bitmap/bitmap.c" target="_blank" rel="external"><code>github</code></a>）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1024</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0xffffffff</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> bitmap[MAXSIZE / (<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) * <span class="number">8</span>) + <span class="number">1</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 置位操作</span></div><div class="line">    bitmap[n &gt;&gt; SHIFT] |= <span class="number">1</span> &lt;&lt; (n &amp; MASK);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 复位操作</span></div><div class="line">    bitmap[n &gt;&gt; SHIFT] &amp;= ~(<span class="number">1</span> &lt;&lt; (n &amp; MASK));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检测是否置位</span></div><div class="line">    <span class="keyword">int</span> i = n &gt;&gt; SHIFT;</div><div class="line">    <span class="keyword">if</span>(bitmap[i] &amp; (<span class="number">1</span> &lt;&lt; (n &amp; MASK)))</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">1023</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"space: %d\n"</span>, <span class="keyword">sizeof</span>(bitmap) / <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));</div><div class="line">    <span class="built_in">set</span>(n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"has set flag: %d\n"</span>, test(n));</div><div class="line">    clr(n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"has set flag: %d\n"</span>, test(n));</div><div class="line">    <span class="built_in">set</span>(n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"has set flag: %d\n"</span>, test(n));</div><div class="line">    clr(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>Bitmap</code>类似于哈希表，哈希规则便是将数字<code>n</code>映射到<code>Bitmap</code>第<code>n</code>个<code>bit</code>上。因此<code>Bitmap</code>在实际应用中存在一处问题——当<code>n</code>取值特别大时，<code>Bitmap</code>占用空间也会比较大。在此业务场景下，<code>Bitmap</code>数据结构是不合理的，所以便衍生出了<code>Bloom Filter</code>。</p><h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><p><code>Bloom Filter</code>，中文译名布隆过滤器，是1970年由布隆提出来的，与<code>Bitmap</code>一脉相承。布隆过滤器可以用于检索一个元素是否在一个集合中。布隆过滤器优点是<em><br><strong>空间复杂度和时间复杂度</strong></em> 都远远超过一般的算法，缺点是<strong><em>有一定的误识别率</em></strong> ，删除困难。</p><p><a href="http://matthias.vallentin.net/course-work/cs270-s11.pdf" target="_blank" rel="external">Bloom Filter Pagers</a></p><p><a href="https://my.oschina.net/kiwivip/blog/133498" target="_blank" rel="external">Bloom Filter算法简介</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;在互联网后台的开发工作中，笔者会经常遇到各种各样的&lt;strong&gt;&lt;em&gt;白名单&lt;/em&gt;&lt;/strong&gt;业务场景，比如以
      
    
    </summary>
    
    
      <category term="算法" scheme="https://blog.nice-ai-life.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://blog.nice-ai-life.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Python list实现</title>
    <link href="https://blog.nice-ai-life.com/2018/01/08/Python-list%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.nice-ai-life.com/2018/01/08/Python-list实现/</id>
    <published>2018-01-08T13:57:35.000Z</published>
    <updated>2018-01-08T16:51:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文所讲<code>Python</code>实现均为<code>CPython</code>，需读者具备一定的<code>C</code>语言阅读能力。本博文参考了<strong><em>《Python源码剖析》</em></strong>与<code>Python2.7</code>源码。<code>PyListObject</code>采用顺序存储（而非链式存储），熟悉<code>数据结构</code>的读者，能很容易明白本博文所讲内容。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>PyListObject</code>是<code>Python</code>提供的<code>List</code>容器实现，与<code>C++ STL</code>中的<code>vector</code>实现机制相近。<code>PyListObject</code>是变长对象同时也是可变对象（很显然，不同时刻<code>List</code>中可以存在不同数目的元素）。</p><p><code>PyListObject</code>定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">PyObject_VAR_HEAD</div><div class="line">PyObject **ob_item;</div><div class="line"><span class="keyword">int</span> allocated;</div><div class="line">&#125; PyListObject;</div></pre></td></tr></table></figure><p><code>PyObject_VAR_HEAD</code>中的<code>ob_size</code>与<code>PyListObject</code>中的<code>allocated</code>字段分别标识了容器的现有<strong><em>元素个数（size）</em></strong>与<strong><em>容器容量（capacity）</em></strong>。<code>ob_item</code>为指向<code>PyObject *</code>的指针（即<code>PyObject *</code>数组），是<code>PyListObject</code>实现顺序存储的数组。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1、创建对象"><a href="#1、创建对象" class="headerlink" title="1、创建对象"></a>1、创建对象</h3><p><code>Python</code>提供了唯一创建<code>List</code>的函数——<code>PyList_New</code>。下面是简化的后<code>Python</code>创建<code>PyListObject</code>对象的过程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFREELISTS 80</span></div><div class="line"><span class="keyword">static</span> PyListObject *free_lists[MAXFREELISTS];</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> num_free_ists = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function">PyObject *<span class="title">PyList_New</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">PyListObject *op;</div><div class="line"><span class="keyword">size_t</span> nbytes;</div><div class="line"><span class="comment">// 判断int类型是否溢出，若溢出则返回内存分配失败</span></div><div class="line">nbytes = size * <span class="keyword">sizeof</span>(PyObject *);</div><div class="line"><span class="keyword">if</span>(nbytes / <span class="keyword">sizeof</span>(PyObject *) != (<span class="keyword">size_t</span>)size) &#123;</div><div class="line"><span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">&#125;</div><div class="line"><span class="comment">//</span></div><div class="line"><span class="keyword">if</span>(num_free_lists) &#123;</div><div class="line"><span class="comment">// 缓冲池可用，则从缓冲池取一可用List</span></div><div class="line">num_free_lists--;</div><div class="line">op = free_lists[num_free_lists];</div><div class="line">_Py_NewReference((PyObject *)op);</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="comment">// 缓冲池不可用，直接新建对象并为Python中的自动垃圾收集机制做一些工作</span></div><div class="line">op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">if</span>(size &lt;= <span class="number">0</span>) &#123;</div><div class="line">op-&gt;ob_item = <span class="literal">NULL</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">op-&gt;ob_item = (PyObject **)PyMem_MALLOC(nbytes);</div><div class="line"><span class="built_in">memset</span>(op-&gt;ob_item, <span class="number">0</span>, nbytes);</div><div class="line">&#125;</div><div class="line">op-&gt;ob_size = size;</div><div class="line">op-&gt;allocated = size;</div><div class="line"><span class="keyword">return</span> (PyObject *)op;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><code>PyListObject</code>对象分为两部分：①<code>PyListObject</code>对象②<code>PyListObject</code>对象容纳的<code>PyObject</code>元素。</p><h3 id="2、设置元素"><a href="#2、设置元素" class="headerlink" title="2、设置元素"></a>2、设置元素</h3><p>前面提到<code>PyListObject</code>是顺序存储，可以<strong><em>随机访问</em></strong>。通过下标设置<code>List</code>中元素值，是由<code>PyList_SetItem</code>函数实现的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyList_SetItem</span><span class="params">(<span class="keyword">register</span> PyObject *op, <span class="keyword">register</span> <span class="keyword">int</span> i, <span class="keyword">register</span> PyObject *new_item)</span> </span>&#123;</div><div class="line"> <span class="comment">// 保存指向旧元素的指针，用于减少引用计数</span></div><div class="line"><span class="keyword">register</span> PyObject *olditem;</div><div class="line"><span class="keyword">register</span> PyObject **p;</div><div class="line"><span class="comment">// 检查索引值得合法性</span></div><div class="line"><span class="keyword">if</span>(i &lt; <span class="number">0</span> || i&gt;= (PyListObject)op-&gt;ob_size) &#123;</div><div class="line"><span class="comment">// 报索引错误</span></div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 设置元素</span></div><div class="line">p = ((PyListObject*)op)-&gt;ob_item + i;</div><div class="line">olditem = *p;</div><div class="line">Py_XDECREF(olditem);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3、插入元素"><a href="#3、插入元素" class="headerlink" title="3、插入元素"></a>3、插入元素</h3><p>了解<code>顺序存储</code>的读者，很容易想到新元素的插入会导致元素的移动。<code>PyListObject</code>的实现也不例外，而这其中又牵扯了<code>PyListObject.ob_item</code>的<strong><em>扩容</em></strong>与<strong><em>缩容</em></strong>（参考<code>Redis</code>或者其它若干软件的实现，都会有类似机制）。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyList_Insert</span><span class="params">(PyObject *op, Py_ssize_t where, PyObject *new_item)</span> </span>&#123;</div><div class="line"><span class="keyword">return</span> insl((PyListObject *)op, where, newitem);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insl</span><span class="params">(PyListObject *self, Py_ssize_t where, PyObject *v)</span> </span>&#123;</div><div class="line">Py_ssize_t i, n = self-&gt;ob_size;</div><div class="line">PyObject **items;</div><div class="line"><span class="comment">// 调整列表容量</span></div><div class="line"><span class="keyword">if</span>(list_resize(self, n+<span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line"><span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line"><span class="comment">// 确定插入点</span></div><div class="line"><span class="keyword">if</span>(where &lt; <span class="number">0</span>) &#123;</div><div class="line"><span class="comment">// 负数索引</span></div><div class="line">where += n;</div><div class="line"><span class="keyword">if</span>(where &lt; <span class="number">0</span>)</div><div class="line">where = <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">if</span>(where &gt; n)</div><div class="line">where = n;</div><div class="line"><span class="comment">// 插入元素</span></div><div class="line">items = self-&gt;ob_item;</div><div class="line"><span class="keyword">for</span>(i = n; --i &gt;= where; )</div><div class="line"><span class="comment">// 从后往前将元素后移一个单位，空出新元素存储单元</span></div><div class="line">item[i+<span class="number">1</span>] = item[i]</div><div class="line"><span class="comment">// 使用宏Py_INCREF增加元素v的引用计数</span></div><div class="line">Py_INCREF(v);</div><div class="line">item[where] = v;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>其中函数<code>list_resize</code>为<code>PyListObject</code>对象<strong><em>扩容</em></strong>与<strong><em>缩容</em></strong>的关键。<code>list_resize</code>函数的实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_resize</span><span class="params">(PyObjectList *self, <span class="keyword">int</span> newsize)</span> </span>&#123;</div><div class="line">PyObject **items;</div><div class="line"><span class="keyword">size_t</span> new_allocated;</div><div class="line"><span class="keyword">int</span> allocated = self-&gt;allocated;</div><div class="line"><span class="comment">// 不需要申请内存</span></div><div class="line"><span class="keyword">if</span>(allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">self-&gt;ob_size = newsize;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 计算重新申请内存的大小</span></div><div class="line">new_allocated = (newsize &gt;&gt; <span class="number">3</span>) + (newsize &lt; <span class="number">9</span> ? <span class="number">3</span> : <span class="number">6</span>) + newsize;</div><div class="line"><span class="keyword">if</span>(newsize == <span class="number">0</span>)</div><div class="line">new_allocated = <span class="number">0</span>;</div><div class="line"><span class="comment">// 扩展列表</span></div><div class="line">items = self-&gt;ob_items;</div><div class="line"><span class="comment">// 最终调用c语言的realloc</span></div><div class="line">PyMem_RESIZE(item, PyObject *, new_allocated);</div><div class="line">self-&gt;ob_itme = items;</div><div class="line">self-&gt;ob_size = newsize;</div><div class="line">self-&gt;allocated = new_allocated;</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>当<code>List</code>新的元素个数<code>newsize</code>，满足条件：<code>allocated/2 &lt;= newsize &lt;= allocated</code>时，不需要进行<code>realloc</code>。当<code>newsize &gt;= allocated</code>时，<code>PyObjectList</code>会进行<strong><em>扩容</em></strong>操作，当<code>newsize &lt; allocated/2</code>时<code>PyObjectList</code>会进行<strong><em>缩容</em></strong>操作。</p><h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p><code>CPython</code>为了解决频繁创建对象带来的性能问题（大多数对性能要求较高的<code>C</code>程序均采用类似机制），采用了大量的<code>对象池</code>技术——<code>PyListObject</code>的实现也不例外。如果读者对此类技术不熟悉，请参阅<strong><em>对象池</em></strong>设计模式。</p><p>在如上<code>PyList_New</code>函数的实现代码中，<code>free_lists</code>指针数组便是用于<code>PyListObject</code>创建的对象池。我们可以看到如果存在可用的<code>PyListObject</code>，<code>Python</code>便会从<code>对象池</code>中取出并返回一个<code>PyListObject</code>对象。那么<code>PyListObject</code>对象是<strong><em>何时、如何</em></strong>归还给对象池的呢？答案就在销毁<code>PyListObject</code>的<code>list_dealloc</code>函数里。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_dealloc</span><span class="params">(PyListObject *op)</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> i;</div><div class="line"><span class="keyword">if</span>(op-&gt;ob_item != <span class="literal">NULL</span>) &#123;</div><div class="line">i = op-&gt;ob_size;</div><div class="line"><span class="keyword">while</span>(--i &gt;= <span class="number">0</span>) &#123;</div><div class="line">Py_XDECREF(op-&gt;ob_item[i]);</div><div class="line">&#125;</div><div class="line">PyMem_FREE(op-&gt;ob_item);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 释放PyListObject自身</span></div><div class="line"><span class="keyword">if</span>(num_free_lists &lt; MAXFREELISTS &amp;&amp; PyList_CheckExact(op))</div><div class="line">free_lists[num_free_lists++] = op;</div><div class="line"><span class="keyword">else</span></div><div class="line">op-&gt;ob_type-&gt;tp_free((PyObject *)op);</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本文所讲&lt;code&gt;Python&lt;/code&gt;实现均为&lt;code&gt;CPython&lt;/code&gt;，需读者具备一定的&lt;code&gt;C&lt;/code&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SkipList研究</title>
    <link href="https://blog.nice-ai-life.com/2017/12/29/SkipList/"/>
    <id>https://blog.nice-ai-life.com/2017/12/29/SkipList/</id>
    <published>2017-12-28T16:37:10.000Z</published>
    <updated>2018-01-06T07:02:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>作为一名学渣，每次回头去翻看一下大学课程的基础知识，总会有不同的感受。笔者也总想着把自己工作中领悟的做归纳。关于查找算法，思想大概可以归类为三类（大神请绕路）：</p><ul><li>顺序查找</li><li>二分查找（插入查找、斐波拉切查找…）</li><li>哈希查找</li></ul><p>顺序查找是我们常用的遍历。在对性能要求比较高的业务场景下，我们便需要考虑其他更好的实现方式了（例如：为了避免全表扫描，数据库通过<code>B+ Tree</code>索引提高查找效率）。哈希查找，时间复杂度为<code>O(1)</code>，是一种常见且应用广泛的查找算法。本文将在剩余篇幅对二分查找法进行吐槽。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>咦？今天我们讨论的不是<code>SkipList</code>吗，为什么会谈到二分查找法，接下来笔者将阐述一下原因。在实际工程应用中，算法与数据结构是相辅相成的，相互依存，相互影响的， 没有<code>数据结构</code>支撑的算法只能是空中阁楼。接下来，我们思考尝试为二分查找（或类似思想）寻找一个适合的<strong><em>数据结构</em></strong>。</p><p>通常会从<code>CRUD</code>（即增、删、改、查）四个角度，结合具体应用场景去衡量一个数据结构的适用性。我们知道数据的存储方式分为两种：①顺序存储②链式存储。<strong>顺序存储</strong>中，有序列表的元素在内存中紧紧相连，可以<strong><em>随机访问</em></strong>（直接用下标访问，时间复杂度<code>O(1)</code>），能用二分查找法快速定位节点。但是顺序存储对<code>增、删</code>操作的处理比较费力（当删除列表中一个元素时，列表应当将该元素后面的元素前移，填补空的节点，同样增加元素时亦是如此）。</p><p>顺序存储不适用于<code>增 、删</code>操作频繁的应用场景，那么我们考虑一下<strong><em>链式存储</em></strong>。<strong><em>链表</em></strong>能很好的处理<code>增、删</code>频繁的场景。但是链表一般<strong><em>顺序访问</em></strong>（即读取第一个元素后才可以读取第二个元素，以此类推），显然传统的链表数据结构无法应用二分的思想进行快速查找。</p><p>聪明的人们结合<code>二叉树</code>，发明了<strong><em>二叉查找树</em></strong>———既可以二分查找，又能够快速<code>添加、删除</code>元素的数据结构。这正是我们期望的能够应用二分查找的完美数据结构吗？很遗憾，并不是。二叉查找树在最坏情况下可能变成一个链表。于是，在二分查找树的基础上，就出现了<code>AVL</code>平衡树。<code>AVL</code>树在<code>增、删</code>节点时，为了保持树的平衡，会进行左旋，右旋操作，增加了<code>增、删</code>操作的复杂度。于是乎根据人们在发明了<code>B-Tree</code>，<code>B+ Tree</code>，<code>红黑树</code>等。但是<code>AVL</code>树实现起来比较复杂，平衡操作较难理解。</p><p>所以便有了<code>SkipList</code>。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>百度搜索网上一些<code>SkipList</code>的实现，代码多多少少存在一些瑕疵。笔者根据自己对<code>SkipList</code>的理解，结合网上的一些实现，整理出了一份<code>C</code>语言版本的<code>SkipList</code>实现。读者可以参阅笔者的<code>GitHub</code>，源文件：<a href="https://github.com/keepalive555/study/blob/master/skiplist/skiplist.c" target="_blank" rel="external">https://github.com/keepalive555/study/blob/master/skiplist/skiplist.c</a>。</p><p>其中<code>SkipList</code>新建<code>Node</code>节点，随机获取节点<code>level</code>值的<code>random_level</code>函数（源码如下所示），是笔者摘抄自<code>Redis</code>源码。<strong><em>该函数是保证<code>SkipList</code>的<code>CRUD</code>操作时间复杂度为</em></strong>O(logN)<strong><em>的核心所在</em></strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEVEL 32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> P 0.25</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_level</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">while</span> ((random() &amp; <span class="number">0xFFFF</span>) &lt; (P * <span class="number">0xFFFF</span>))  </div><div class="line">        level += <span class="number">1</span>;  </div><div class="line">    <span class="keyword">return</span> (level &lt; MAX_LEVEL) ? level : MAX_LEVEL;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h2&gt;&lt;p&gt;作为一名学渣，每次回头去翻看一下大学课程的基础知识，总会有不同的感受。笔者也总想着把自己工作中领悟的做归纳。关于查找算法，思想大概可以归类为
      
    
    </summary>
    
    
      <category term="datastructs" scheme="https://blog.nice-ai-life.com/tags/datastructs/"/>
    
      <category term="algorithm" scheme="https://blog.nice-ai-life.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Raft协议</title>
    <link href="https://blog.nice-ai-life.com/2017/12/23/raft%E5%8D%8F%E8%AE%AE/"/>
    <id>https://blog.nice-ai-life.com/2017/12/23/raft协议/</id>
    <published>2017-12-23T13:14:30.000Z</published>
    <updated>2017-12-29T16:49:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式，很多初学者对这个词的第一印象——高大上技术范儿。抛开技术细节不谈，纵观后台技术的发展，存在着普遍适用的规律，一项新技术的诞生，总是解决一些现有架构无法解决的问题。如果读者凭空去学习分布式，便容易坠入云里雾里。本文作为笔者自己学习的一个梳理，以实际问题出发阐述了笔者对<code>Raft</code>协议的理解。本文并不对<code>Raft</code>协议的实现机制做详细的描述，只是从一个新手解决问题的角度去阐述<code>Raft</code>协议做了些什么，不正确的地方请读者指正（邮箱：<a href="mailto:dreamcatchwang1991@gmail.com" target="_blank" rel="external">dreamcatchwang1991@gmail.com</a>）。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>以经典单数据库实例架构（这也是很多企业级应用的典型架构）为例，所有的业务数据均存储于单机数据库，当数据库实例<code>Crash</code>了以后，业务便受到影响，在大多数情况下，这种<code>Crash</code>对企业业务的影响是可控范的。然而在互联网应用中，哪怕是一分钟的<code>Crash</code>对企业来说也是致命的，比如前段时间，美团的外卖系统出现崩溃，整个服务停摆几个小时，造成大量用户流失到饿了么平台。 </p><p>笔者尝试根据自己的经验去解决该问题，为了让单机数据库实例在<code>Crash</code>了以后,整个系统仍然保持可用，我们很容易想到的一个策略——冗余（比如你在单位请假了需要有人代替你继续工作而不影响业务）。我们增加了一台数据库实例<code>B</code>（原来的数据库实例用<code>A</code>表示），在实例<code>A</code>挂掉了之后，我们期望<code>B</code>可以代替<code>A</code>继续提供服务，<strong><em>所以<code>B</code>与<code>A</code>必须具备一样的数据</em></strong>，在分布式里面这个称作<strong><em>一致性</em></strong>。<code>Raft</code>协议为<strong><em>分布式一致性协议</em></strong>的一种实现，主要目标就是解决上述这类问题。</p><p>脱离现有的<code>MySQL</code>，<code>Redis</code>，<code>Kafka</code>等高可用方案（因为这些系统为了性能而做出一些折中），我们根据自己的诉求，去设计一个高可用的存储系统，需要注意哪些问题呢？假设我们的存储系统有<code>A</code>,<code>B</code>,<code>C</code>等3个节点用来保持高可用，那我们该怎么保持<code>A</code>,<code>B</code>,<code>C</code>3个节点内数据的一致性呢？</p><ul><li>一致性由客户端保证还是服务端保证</li><li>如何保证<code>A,B,C</code>或更多节点的数据一致性</li></ul><p>首先分析第一个问题，假设一致性工作是由客户端保证的（客户端向<code>A</code>写入数据的同时向<code>B</code>和<code>C</code>写入数据，为保证<code>A,B,C</code>的一致性，需<code>A,B,C</code>3个节点全部写入成功，客户端回才判定写入成功），我们可能会遇到如下情况:</p><ul><li><code>B</code>下线了一段时间又重新上线，因为客户端未保存<code>B</code>处于下线状态这段时间的数据，所以<code>B</code>中就会缺失这部分数据，因而<code>B</code>中数据会与<code>A</code>与<code>C</code>中数据不一致。</li><li>客户端向<code>A</code>与<code>C</code>中写入数据成功，但向<code>B</code>中写入数据失败，这次写入应当被认定为失败（因为<code>A</code>,<code>B</code>,<code>C</code>中数据不一致，也无法通过其他途径达到一致），我们期望整个系统可以表现的犹如一个<strong><em>事务</em></strong>，要么全部成功，要么全部失败回滚修改，客户端无法提供这种机制。</li></ul><p>综上，<strong><em>由客户端保证数据的一致性是不可取的</em></strong>。 </p><p>我们将一致性保证工作放在服务端实现，那么我们如何保证<code>A,B,C</code>三节点数据的一致性呢？首先我们思考一个问题，<strong><em>我们无法预知<code>A,B,C</code>三个节点中哪个节点会意外挂掉，所以客户端不应该至同单一节点建立联系</em></strong>，也就是说——<code>A,B,C</code>3个节点对外应当表现为一个整体，也就是集群<code>Cluster</code>。那么客户端该如何向<code>A,B,C</code>组成的集群写入数据？以下是笔者想到的实现方式：</p><ul><li>所有客户端均向<code>A,B,C</code>中某一节点（比如<code>A</code>）写入数据，由该节点将数据拷贝至其它节点以达到一致性。</li><li>向建立连接的节点写入数据，比如<code>客户端1</code>同<code>A</code>建立连接，<code>客户端1</code>向<code>A</code>写入数据，<code>客户端2</code>同<code>B</code>建立连接，<code>客户端2</code>向<code>B</code>写入数据，以此类推。</li></ul><p>读者是否觉得以上两种实现方式似曾相识——这和<strong><em>并发编程</em></strong>下的并发更改共享变量问题相似，由经验我们可知，我们最好是将对共享的操作<strong><em>串行，有序的</em></strong>执行。同样，如果多个客户端通过多个节点向集群写入数据，为了达到每个节点都有一份完整数据的目的，多个节点间会进行通讯，数据合并，而这其中又牵扯了数据的顺序等许多问题，工程实现起来比较复杂。<br>当然不是说不可以，笔者没见过这么做的~ ~）</p><p>方式一为目前流行的一致性解决思路，<code>Raft</code>协议采用了该思路，<code>Raft</code>协议解决了方式一面临的两大问题：</p><ul><li>集群启动（或者写入节点下线）时，如何选举出一个节点作为写入节点</li><li>写入节点如何与其它节点通讯，复制数据，保持数据在各节点的一致性</li></ul><p>以上两大问题便是<code>Raft</code>协议的两大功能：</p><ul><li><code>Leader Election</code></li><li><code>Log Replication</code></li></ul><p>分布式中任何环节都是不可靠的，实际问题比本人论述的复杂的多，但明确了上述问题，再去研究<code>Raft Paper</code>时，读者便可以快速掌握<code>Raft</code>协议。</p><p>建议大家观看<code>Raft</code>协议动画，简单明了生动：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://raft.github.io/raft.pdf" target="_blank" rel="external">Raft Pager</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;分布式，很多初学者对这个词的第一印象——高大上技术范儿。抛开技术细节不谈，纵观后台技术的发展，存在着普遍适用的规律，一项新技术的诞生，总是解
      
    
    </summary>
    
    
      <category term="algorithm" scheme="https://blog.nice-ai-life.com/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>线段树应用（编辑中）</title>
    <link href="https://blog.nice-ai-life.com/2017/12/23/%E7%BA%BF%E6%AE%B5%E6%A0%91%E5%BA%94%E7%94%A8/"/>
    <id>https://blog.nice-ai-life.com/2017/12/23/线段树应用/</id>
    <published>2017-12-22T18:25:15.000Z</published>
    <updated>2017-12-25T14:08:09.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习工作多年，逐渐悟得一名优秀的程序员应有的态度———<strong><em>优雅的解决问题</em></strong>。简而言之，解决问题并不是最终解，如何求得该问题的最优解才是一名优秀程序员应该考虑的问题。<code>360</code>同事对待问题的态度让我这种感觉愈发强烈。</p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>最近笔者在考虑如下一个需求：</p><blockquote><p>现有一集团，内部网络划分为N多个子网（N&gt;100），该N多个子网网段互相之间不交叉。有一批告警数据，该数据里携带了产生告警事件的设备<code>IPv4</code>地址，现笔者需要根据设备<code>IPv4</code>地址，将这些告警数据按子网网段分类。</p></blockquote><p>以上问题可抽象为：</p><p>问题Q：存在区间[1, 100]，该区间是由[1, 10], [11, 20], [21, 30]…[91, 100]等子区间组成，现给定一个正整数N（1 &lt;= N &lt;= 100），求解N落在那个子区间。 </p><blockquote><p>注解：将N多个子网网段用区间（由计算机网络可知<code>IPv4</code>地址为32位无符号整数）的形式表现，比如子网网段<code>10.95.12.0/24</code>表示的<code>IPv4</code>地址范围为：<code>10.95.12.0</code> ~ <code>10.95.12.255</code>（即：<code>0xa5f0c00</code>~<code>0xaf0cff</code>），其他网段类推，由此可见该需求属于我们问题Q的同一类问题。</p></blockquote><p>我们尝试去解决问题Q，首先比较容易想到，也是实现比较简单的便是<strong><em>遍历</em></strong>[1, 10], [11, 20]…[91, 100]等所有子区间，用N与子区间的左右端点作比较，确定N所在的子区间。显而易见，该方法简单明了，时间复杂度为O(n)。</p><p>子区间数目越多，遍历一次花费的代价就越大，在海量数据的处理中，这显然是不可忍受的。我们观察到子区间[1, 10], [11, 20], [21, 30]…[91, 100]是连续的，于是我们自然而然的想到了二分查找与二叉搜索树，不同的是以前我们接触的大多是单个节点的查找，现在是范围（即：子区间）的查找，由此今天的主角便登场了——线段树（又名区间树）。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;学习工作多年，逐渐悟得一名优秀的程序员应有的态度———&lt;strong&gt;&lt;em&gt;优雅的解决问题&lt;/em&gt;&lt;/strong&gt;。简而言之，解决问题
      
    
    </summary>
    
    
      <category term="algorithms" scheme="https://blog.nice-ai-life.com/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>Tornado IOLoop图解</title>
    <link href="https://blog.nice-ai-life.com/2017/12/22/IOLoop%E7%AE%80%E8%BF%B0/"/>
    <id>https://blog.nice-ai-life.com/2017/12/22/IOLoop简述/</id>
    <published>2017-12-22T05:26:57.000Z</published>
    <updated>2017-12-29T17:06:39.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tornado-IOLoop简述"><a href="#Tornado-IOLoop简述" class="headerlink" title="Tornado IOLoop简述"></a>Tornado IOLoop简述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者信奉这样一种哲学——“把书从薄读厚，然后从厚读薄”，<code>Tornado</code>源码犹如一部文学作品，汇集了众多优秀<code>Python</code>工程师的智慧结晶，奇思妙想让人拍手连连。一本好书每读一次，都有不同的感受，代码也是如此。为了能够在以后的工作学习中时时回顾品味一下，笔者决定将笔者对<code>Tornado</code>的理解以图记录下来。</p><p>在这里笔者推荐一款强大的在线绘图软件：<a href="https://www.draw.io/" target="_blank" rel="external">https://www.draw.io/</a>，想要<code>Visio</code>的专业，却不喜欢<code>Visio</code>笨重的读者绝对会让你好用到<code>Cry</code>。</p><h2 id="IOLoop图示"><a href="#IOLoop图示" class="headerlink" title="IOLoop图示"></a>IOLoop图示</h2><p><strong><em>注意：</em></strong> 对<code>IO</code>多路复用技术不了解的同学，可以先了解一下 <strong><em>阻塞/非阻塞，同步/异步，select，epoll</em></strong> 等概念。</p><p>笔者注意到，任何语言的事件循环（比如：<code>libev</code>，<code>nodejs</code>，…），最核心的<code>Feature</code>是相同的，不一样的只不过是实现方式，抽象层次不同，笔者将这些核心<code>Feature</code>总结如下：</p><ul><li>文件<code>IO</code>事件（比如：<code>socket</code>，<code>pipe</code>等<code>READ</code>，<code>WRITE</code>，<code>HUP</code>事件 …）</li><li>系统信号(比如：<code>SIGINT</code>,<code>SIGHUP</code>…)</li><li>定时器</li></ul><p><code>Tornado IOLoop</code>的实现也不例外，如下图所示：</p><p><img src="/2017/12/22/IOLoop简述/ioloop.jpg" alt="IOLoop示意图"></p><h2 id="IOLoop代码随笔"><a href="#IOLoop代码随笔" class="headerlink" title="IOLoop代码随笔"></a>IOLoop代码随笔</h2><p>以下是笔者对<code>IOLoop</code>核心方法<code>start</code>的源码注解，可以用于结合图示，加深理解。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">if</span> self._running:</div><div class="line">        <span class="comment"># IOLoop已经启动。</span></div><div class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"IOLoop is already running"</span>)</div><div class="line">    self._setup_logging()  <span class="comment"># 开始安装日志模块。</span></div><div class="line">    <span class="keyword">if</span> self._stopped:</div><div class="line">        self._stopped = <span class="keyword">False</span>  <span class="comment"># 如果已经停止，则直接返回。</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="comment"># 获取当前线程的IOLoop实例。</span></div><div class="line">    old_current = getattr(IOLoop._current, <span class="string">"instance"</span>, <span class="keyword">None</span>)</div><div class="line">    IOLoop._current.instance = self  <span class="comment"># 将当前IOLoop实例置为self。</span></div><div class="line">    self._thread_ident = thread.get_ident()  <span class="comment"># 线程id。</span></div><div class="line">    self._running = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="comment"># signal.set_wakeup_fd closes a race condition in event loops:</span></div><div class="line">    <span class="comment"># a signal may arrive at the beginning of select/poll/etc</span></div><div class="line">    <span class="comment"># before it goes into its interruptible sleep, so the signal</span></div><div class="line">    <span class="comment"># will be consumed without waking the select.  The solution is</span></div><div class="line">    <span class="comment"># for the (C, synchronous) signal handler to write to a pipe,</span></div><div class="line">    <span class="comment"># which will then be seen by select.</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># In python's signal handling semantics, this only matters on the</span></div><div class="line">    <span class="comment"># main thread (fortunately, set_wakeup_fd only works on the main</span></div><div class="line">    <span class="comment"># thread and will raise a ValueError otherwise).</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># If someone has already set a wakeup fd, we don't want to</span></div><div class="line">    <span class="comment"># disturb it.  This is an issue for twisted, which does its</span></div><div class="line">    <span class="comment"># SIGCHLD processing in response to its own wakeup fd being</span></div><div class="line">    <span class="comment"># written to.  As long as the wakeup fd is registered on the IOLoop,</span></div><div class="line">    <span class="comment"># the loop will still wake up and everything should work.</span></div><div class="line"></div><div class="line">    <span class="comment"># wakeup_fd是用来唤醒主事件循环（信号唤醒，或者从别的线程唤醒主线程）。</span></div><div class="line">    old_wakeup_fd = <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> hasattr(signal, <span class="string">'set_wakeup_fd'</span>) <span class="keyword">and</span> os.name == <span class="string">'posix'</span>:</div><div class="line">        <span class="comment"># requires python 2.6+, unix.  set_wakeup_fd exists but crashes</span></div><div class="line">        <span class="comment"># the python process on windows.</span></div><div class="line"></div><div class="line">        <span class="comment"># Python2.6版本以上，Unix-like系统中，signal模块支持set_wakeup_fd方法。</span></div><div class="line">        <span class="comment"># Windows上siganl存在该方法，但是会crash。</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())</div><div class="line">            <span class="keyword">if</span> old_wakeup_fd != <span class="number">-1</span>:</div><div class="line">                <span class="comment"># Already set, restore previous value.  This is a little racy,</span></div><div class="line">                <span class="comment"># but there's no clean get_wakeup_fd and in real use the</span></div><div class="line">                <span class="comment"># IOLoop is just started once at the beginning.</span></div><div class="line">                signal.set_wakeup_fd(old_wakeup_fd)</div><div class="line">                old_wakeup_fd = <span class="keyword">None</span></div><div class="line">        <span class="keyword">except</span> ValueError:</div><div class="line">            <span class="comment"># Non-main thread, or the previous value of wakeup_fd</span></div><div class="line">            <span class="comment"># is no longer valid.</span></div><div class="line">            <span class="comment"># 参考signal的官方手册，set_wakeup_fd仅可在主线程中调用。</span></div><div class="line">            old_wakeup_fd = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="comment"># Prevent IO event starvation by delaying new callbacks</span></div><div class="line">            <span class="comment"># to the next iteration of the event loop.</span></div><div class="line">            <span class="comment"># ncallbacks记录了此次循环的回调函数个数，新增加的回调函数将要在下次循环被调用。</span></div><div class="line">            ncallbacks = len(self._callbacks)</div><div class="line"></div><div class="line">            <span class="comment"># Add any timeouts that have come due to the callback list.</span></div><div class="line">            <span class="comment"># Do not run anything until we have determined which ones</span></div><div class="line">            <span class="comment"># are ready, so timeouts that call add_timeout cannot</span></div><div class="line">            <span class="comment"># schedule anything in this iteration.</span></div><div class="line">            due_timeouts = []  <span class="comment"># 即将超时的任务。</span></div><div class="line">            <span class="keyword">if</span> self._timeouts:</div><div class="line">                now = self.time()</div><div class="line">                <span class="keyword">while</span> self._timeouts:</div><div class="line">                    <span class="keyword">if</span> self._timeouts[<span class="number">0</span>].callback <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                        <span class="comment"># The timeout was cancelled.  Note that the</span></div><div class="line">                        <span class="comment"># cancellation check is repeated below for timeouts</span></div><div class="line">                        <span class="comment"># that are cancelled by another timeout or callback.</span></div><div class="line">                        heapq.heappop(self._timeouts)</div><div class="line">                        self._cancellations -= <span class="number">1</span></div><div class="line">                    <span class="keyword">elif</span> self._timeouts[<span class="number">0</span>].deadline &lt;= now:</div><div class="line">                        due_timeouts.append(heapq.heappop(self._timeouts))</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="keyword">break</span></div><div class="line">                <span class="keyword">if</span> (self._cancellations &gt; <span class="number">512</span> <span class="keyword">and</span></div><div class="line">                        self._cancellations &gt; (len(self._timeouts) &gt;&gt; <span class="number">1</span>)):</div><div class="line">                    <span class="comment"># Clean up the timeout queue when it gets large and it's</span></div><div class="line">                    <span class="comment"># more than half cancellations.</span></div><div class="line">                    <span class="comment"># 如果定时任务取消数量大于512，并且超过总定时任务的半数，则清理self._timeouts，并重新平衡堆。</span></div><div class="line">                    self._cancellations = <span class="number">0</span></div><div class="line">                    self._timeouts = [x <span class="keyword">for</span> x <span class="keyword">in</span> self._timeouts</div><div class="line">                                      <span class="keyword">if</span> x.callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>]</div><div class="line">                    heapq.heapify(self._timeouts)</div><div class="line"></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(ncallbacks):</div><div class="line">                <span class="comment"># 执行回调函数。</span></div><div class="line">                self._run_callback(self._callbacks.popleft())</div><div class="line">            <span class="keyword">for</span> timeout <span class="keyword">in</span> due_timeouts:</div><div class="line">                <span class="comment"># 执行定时任务。</span></div><div class="line">                <span class="keyword">if</span> timeout.callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    self._run_callback(timeout.callback)</div><div class="line">            <span class="comment"># Closures may be holding on to a lot of memory, so allow</span></div><div class="line">            <span class="comment"># them to be freed before we go into our poll wait.</span></div><div class="line">            due_timeouts = timeout = <span class="keyword">None</span>  <span class="comment"># 防止内存泄漏</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> self._callbacks:</div><div class="line">                <span class="comment"># If any callbacks or timeouts called add_callback,</span></div><div class="line">                <span class="comment"># we don't want to wait in poll() before we run them.</span></div><div class="line">                <span class="comment"># 如果发现新增的_callbacks，（回调函数执行时加入了新的回调函数）。</span></div><div class="line">                poll_timeout = <span class="number">0.0</span></div><div class="line">            <span class="keyword">elif</span> self._timeouts:</div><div class="line">                <span class="comment"># If there are any timeouts, schedule the first one.</span></div><div class="line">                <span class="comment"># Use self.time() instead of 'now' to account for time</span></div><div class="line">                <span class="comment"># spent running callbacks.</span></div><div class="line">                poll_timeout = self._timeouts[<span class="number">0</span>].deadline - self.time()  <span class="comment"># 距离将来最近一次定时任务的时间，wait该时间。</span></div><div class="line">                poll_timeout = max(<span class="number">0</span>, min(poll_timeout, _POLL_TIMEOUT))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="comment"># No timeouts and no callbacks, so use the default.</span></div><div class="line">                <span class="comment"># 未发现新的回调函数与定时任务，则调用poll，等待IO事件，超时事件为3600秒。</span></div><div class="line">                poll_timeout = _POLL_TIMEOUT</div><div class="line"></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._running:</div><div class="line">                <span class="comment"># 如果回调函数中有调用stop的则，跳出事件循环。</span></div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                <span class="comment"># clear alarm so it doesn't fire while poll is waiting for</span></div><div class="line">                <span class="comment"># events.</span></div><div class="line">                signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="comment"># 等待IO事件，events_pairs内容为：[(fd, events), (fd, events), ]</span></div><div class="line">                event_pairs = self._impl.poll(poll_timeout)</div><div class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">                <span class="comment"># Depending on python version and IOLoop implementation,</span></div><div class="line">                <span class="comment"># different exception types may be thrown and there are</span></div><div class="line">                <span class="comment"># two ways EINTR might be signaled:</span></div><div class="line">                <span class="comment"># * e.errno == errno.EINTR</span></div><div class="line">                <span class="comment"># * e.args is like (errno.EINTR, 'Interrupted system call')</span></div><div class="line"></div><div class="line">                <span class="comment"># poll陷入内核态以后，进程捕获到的信号会导致poll wait结束，并且错误码为EINTR。</span></div><div class="line">                <span class="keyword">if</span> errno_from_exception(e) == errno.EINTR:</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">raise</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                signal.setitimer(signal.ITIMER_REAL,</div><div class="line">                                 self._blocking_signal_threshold, <span class="number">0</span>)</div><div class="line"></div><div class="line">            <span class="comment"># Pop one fd at a time from the set of pending fds and run</span></div><div class="line">            <span class="comment"># its handler. Since that handler may perform actions on</span></div><div class="line">            <span class="comment"># other file descriptors, there may be reentrant calls to</span></div><div class="line">            <span class="comment"># this IOLoop that modify self._events</span></div><div class="line">            self._events.update(event_pairs)</div><div class="line">            <span class="keyword">while</span> self._events:</div><div class="line">                fd, events = self._events.popitem()</div><div class="line">                <span class="keyword">try</span>:</div><div class="line">                    <span class="comment"># 获取file-like object，与IO事件的处理函数handler。</span></div><div class="line">                    fd_obj, handler_func = self._handlers[fd]</div><div class="line">                    <span class="comment"># 调用handler，处理fd_obj上发生的events事件，</span></div><div class="line">                    <span class="comment"># handler_func在add_handler时候，加入了对事件处理的wraps。</span></div><div class="line">                    handler_func(fd_obj, events)</div><div class="line">                <span class="keyword">except</span> (OSError, IOError) <span class="keyword">as</span> e:</div><div class="line">                    <span class="keyword">if</span> errno_from_exception(e) == errno.EPIPE:</div><div class="line">                        <span class="comment"># Happens when the client closes the connection</span></div><div class="line">                        <span class="comment"># 客户端关闭了同服务器的连接。</span></div><div class="line">                        <span class="keyword">pass</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="comment"># 处理异常。</span></div><div class="line">                        self.handle_callback_exception(self._handlers.get(fd))</div><div class="line">                <span class="keyword">except</span> Exception:</div><div class="line">                    self.handle_callback_exception(self._handlers.get(fd))</div><div class="line">            fd_obj = handler_func = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="comment"># reset the stopped flag so another start/stop pair can be issued</span></div><div class="line">        self._stopped = <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">        <span class="comment"># 还原前一个IOLoop实例（作者也说了这种情况基本没有...）</span></div><div class="line">        IOLoop._current.instance = old_current</div><div class="line">        <span class="keyword">if</span> old_wakeup_fd <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            signal.set_wakeup_fd(old_wakeup_fd)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Tornado-IOLoop简述&quot;&gt;&lt;a href=&quot;#Tornado-IOLoop简述&quot; class=&quot;headerlink&quot; title=&quot;Tornado IOLoop简述&quot;&gt;&lt;/a&gt;Tornado IOLoop简述&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="tornado" scheme="https://blog.nice-ai-life.com/tags/tornado/"/>
    
  </entry>
  
  <entry>
    <title>Python内存回收机制</title>
    <link href="https://blog.nice-ai-life.com/2017/11/13/Python%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>https://blog.nice-ai-life.com/2017/11/13/Python内存回收机制/</id>
    <published>2017-11-13T15:28:54.000Z</published>
    <updated>2017-11-13T15:29:44.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python2-7内存回收机制-一"><a href="#Python2-7内存回收机制-一" class="headerlink" title="Python2.7内存回收机制(一)"></a>Python2.7内存回收机制(一)</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><code>Python</code>的内存回收采用<em>引用计数</em>机制。引用计数是一种简单而广泛使用的资源回收机制，例如<code>Linux</code>平台的<em>文件描述符</em>，<code>Windows</code>平台下的<em>内核对象</em>等均采用引用计数的方式进行管理。本文将结合<code>Python2.7</code>官方手册阐明<code>Python2.7</code>的<em>引用计数机制</em>（如无特殊说明，本文所提及的<code>Python</code>均为<code>CPython</code>）。</p><p><code>Python</code>语言在设计之初就是一门面向对象的语言，即一切皆为对象，在<code>Python</code>官方介绍通用对象结构<a href="https://docs.python.org/2/c-api/structures.html#c.PyObject" target="_blank" rel="external"><code>Common Object Structures</code></a>一文中，有这样一段话：</p><blockquote><p>All Python objects ultimately share a small number of fields at the beginning of the object’s representation in memory. These are represented by the<a href="https://docs.python.org/2/c-api/structures.html#c.PyObject" target="_blank" rel="external"><code>PyObject</code></a> and <a href="https://docs.python.org/2/c-api/structures.html#c.PyVarObject" target="_blank" rel="external"><code>PyVarObject</code></a> types, which are defined, in turn, by the expansions of some macros also used, whether directly or indirectly, in the definition of all other Python objects.</p></blockquote><p>简单来说，<code>Python</code>中所有对象的开始位置，都有一组成员变量，以<code>C</code>语言的两个自定义类型——<code>PyObject</code>与<code>PyVarObject</code>来表示（有兴趣的，可以通读<code>Common Object Structures</code>一文，或者参考《<code>Python源代码剖析</code>》一书，这里不做具体阐述)，<code>PyObject</code>与<code>PyVarObject</code>的开始位置都有一组相同的成员变量（分别由宏<code>PyObject_HEAD</code>，<code>PyObject_HEAD</code>扩展）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Py_ssize_t ob_refcnt;  <span class="comment">// 对象引用计数</span></div><div class="line">PyTypeObject *ob_type;  <span class="comment">// 指向对象类型结构体的指针（与本文无关不做具体阐述）</span></div></pre></td></tr></table></figure><p>由此可见，在<code>CPython</code>实现中，每个<code>Python</code>对象均有一个名为<code>ob_refcnt</code>的成员变量用于标识该对象的引用计数。而众所周知，在<code>Python</code>的实现中，变量只是保存了一个对象的引用（即指针），而非对象本身，所以每当一个<code>Python</code>对象被一个不同变量所引用时，对象的引用计数就会+1，相反当变量不再引用该对象时，该对象的引用计数就会-1，当对象的引用计数变为0时，该对象就会在未来的某个时间被<code>Python</code>的垃圾回收器所回收。</p><p>通过<code>Python</code>的<code>sys</code>模块的<code>getrefcount</code>方法可以获取<code>Python</code>对象的当前引用计数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">        a = A()</div><div class="line">     b = c = a</div><div class="line">     print(sys.getrefcount(a))</div></pre></td></tr></table></figure><pre><code>示例运行结果为4，比实际引用数量（a, b, c）多1，那么为什么会这样呢，`sys.getrefcount`的文档作出了说明：&gt;Return the reference count of the *object*. The count returned is generally one higher than you might expect, because it includes the (temporary) reference as an argument to [`getrefcount()`](https://docs.python.org/2.7/library/sys.html#sys.getrefcount).把对象当做参数调用`sys.getrefcount`方法会增加对象的一个临时引用计数。</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Python2-7内存回收机制-一&quot;&gt;&lt;a href=&quot;#Python2-7内存回收机制-一&quot; class=&quot;headerlink&quot; title=&quot;Python2.7内存回收机制(一)&quot;&gt;&lt;/a&gt;Python2.7内存回收机制(一)&lt;/h1&gt;&lt;h2 id=&quot;写在前
      
    
    </summary>
    
    
      <category term="Python" scheme="https://blog.nice-ai-life.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Huffman编码</title>
    <link href="https://blog.nice-ai-life.com/2017/08/31/Huffman%E7%BC%96%E7%A0%81/"/>
    <id>https://blog.nice-ai-life.com/2017/08/31/Huffman编码/</id>
    <published>2017-08-30T16:45:00.000Z</published>
    <updated>2017-08-31T15:53:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h1><p><strong>注意：</strong> <a href="">原创技术博客，转载请注明原文地址</a>。</p><h2 id="Huffman编码简介"><a href="#Huffman编码简介" class="headerlink" title="Huffman编码简介"></a>Huffman编码简介</h2><p>依然记得初次接触<code>Huffman</code>编码，是在大一的《计算机组成原理》课程上，老师采用<code>Huffman</code>编码实现了一种<code>CPU</code>（虚拟机字节码同理）变长指令集。当时感觉特别神奇，后来又在《数据结构》课程上接触到了<code>Huffman Tree</code>（霍夫曼树），算是对<code>Huffman</code>编码有了一个比较全面的认识。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="string">"""Huffman编码Python实现。"""</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, score, value=None, lchild=None, rchild=None)</span>:</span></div><div class="line">        self.score = score</div><div class="line">        self.value = value</div><div class="line">        self.lchild = lchild</div><div class="line">        self.rchild = rchild</div><div class="line">        self.bit = <span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_huffman_tree</span><span class="params">(sequence)</span>:</span></div><div class="line"></div><div class="line">    char2frequency = dict()</div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> sequence:</div><div class="line">        char2frequency.setdefault(c, <span class="number">0</span>)</div><div class="line">        char2frequency[c] += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_cmp</span><span class="params">(a, b)</span>:</span></div><div class="line">        delta = a.score - b.score</div><div class="line">        <span class="keyword">if</span> delta != <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> sequence.index(a.value) - sequence.index(b.value)</div><div class="line">        <span class="keyword">return</span> delta</div><div class="line"></div><div class="line">    queue = [Node(char2frequency[x], x) <span class="keyword">for</span> x <span class="keyword">in</span> set(sequence)]</div><div class="line">    queue.sort(cmp=_cmp)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> len(queue) &gt; <span class="number">1</span>:</div><div class="line">        lchild, rchild = queue.pop(), queue.pop()</div><div class="line">        lchild.bit, rchild.bit = <span class="number">0</span>, <span class="number">1</span></div><div class="line">        parent_node = Node(</div><div class="line">            lchild.score+rchild.score, lchild=lchild, rchild=rchild)</div><div class="line">        queue.insert(<span class="number">0</span>, parent_node)</div><div class="line">        queue.sort(key=<span class="keyword">lambda</span> o: o.score)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> queue[<span class="number">0</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_check_list</span><span class="params">(node)</span>:</span></div><div class="line"></div><div class="line">    stack = []</div><div class="line">    check_list = dict()</div><div class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">or</span> stack:</div><div class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            stack.append(node)</div><div class="line">            node = node.lchild</div><div class="line">        <span class="keyword">if</span> stack:</div><div class="line">            node = stack.pop()</div><div class="line">            <span class="keyword">if</span> node.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                sequence = [x.bit <span class="keyword">for</span> x <span class="keyword">in</span> stack]</div><div class="line">                sequence.append(node.bit)</div><div class="line">                check_list[node.value] = int(<span class="string">''</span>.join(map(str, sequence)), <span class="number">2</span>)</div><div class="line">            node = node.rchild</div><div class="line">    <span class="keyword">return</span> check_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    tree = generate_huffman_tree(<span class="string">'shootsheetjobwork'</span>)</div><div class="line">    check_list = generate_check_list(tree)</div><div class="line">    <span class="keyword">print</span> check_list</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Huffman编码&quot;&gt;&lt;a href=&quot;#Huffman编码&quot; class=&quot;headerlink&quot; title=&quot;Huffman编码&quot;&gt;&lt;/a&gt;Huffman编码&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; &lt;a href=&quot;&quot;&gt;原创技术博客，转载请
      
    
    </summary>
    
      <category term="Alg" scheme="https://blog.nice-ai-life.com/categories/Alg/"/>
    
    
      <category term="Alg" scheme="https://blog.nice-ai-life.com/tags/Alg/"/>
    
  </entry>
  
  <entry>
    <title>MySQL前缀索引</title>
    <link href="https://blog.nice-ai-life.com/2017/07/31/MySQL%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95/"/>
    <id>https://blog.nice-ai-life.com/2017/07/31/MySQL前缀索引/</id>
    <published>2017-07-31T14:42:18.000Z</published>
    <updated>2017-07-31T14:43:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL前缀索引"><a href="#MySQL前缀索引" class="headerlink" title="MySQL前缀索引"></a>MySQL前缀索引</h2><p><strong>注意：</strong> 本文的所有优化仅针对InnoDB存储引擎。</p><p>MySQL索引可以加快查询速度，但是索引并不是越多越好，索引虽然可以加快数据的查询速度，但是索引文件本身需要占用存储空间，数据的插入，删除，和修改也需要索引保持同步，据一线有经验的DBA介绍，索引列占表所有列的30%是比较合理的。</p><h4 id="查看表存在的索引"><a href="#查看表存在的索引" class="headerlink" title="查看表存在的索引"></a>查看表存在的索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> <span class="string">`table`</span>;</div></pre></td></tr></table></figure><h4 id="查看索引占用磁盘空间大小"><a href="#查看索引占用磁盘空间大小" class="headerlink" title="查看索引占用磁盘空间大小"></a>查看索引占用磁盘空间大小</h4><blockquote><p>MySQL<code>information_schema</code>数据库<code>TABLES</code>表<a href="https://dev.mysql.com/doc/refman/5.7/en/tables-table.html" target="_blank" rel="external">官方手册</a></p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">concat</span>(<span class="keyword">round</span>(<span class="keyword">sum</span>(INDEX_LENGTH/(<span class="number">1024</span>*<span class="number">1024</span>)), <span class="number">2</span>), <span class="string">'MB'</span>) <span class="keyword">as</span> <span class="string">'Total Index Size'</span> <span class="keyword">from</span> <span class="string">`information_schema`</span>.<span class="string">`TABLES`</span> <span class="keyword">where</span> <span class="string">`table_schema`</span> = <span class="string">'order'</span> <span class="keyword">and</span> <span class="string">`table_name`</span> = <span class="string">'order_base'</span>;</div></pre></td></tr></table></figure><p><strong>注意：</strong> 以下两种情况，不建议建立索引。</p><ul><li>表记录数比较少 —— InnoDB辅助索引叶子节点存储的不是记录的物理地址，而是主键值，使用辅助索引查找数据总是需要第二次查找主键索引，在表记录较少的情况下，建立索引反而会降低查询性能，所以直接全表扫描就好了，具体基准需根据业务场景而定。</li><li>索引的选择性比较低 —— 索引的选择性指不重复的索引值与表记录数的比值，值域为(0, 1]。索引选择性越高越好，可以通俗的理解为，选择性高的索引在查询时往往可以筛选出比较多的记录，所以访问表的次数较少，索引的有效率比较高。例如存在基本表<code>table</code>，我们要在表<code>table</code>的<code>column</code>列上建立一个索引，我们使用如下<code>SQL</code>语句计算该索引的选择性：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="string">`column`</span>) / <span class="keyword">select</span> <span class="keyword">count</span>(*) <span class="keyword">from</span> <span class="string">`table`</span>;</div></pre></td></tr></table></figure><h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><p>前缀索引是一种与索引选择性相关联的索引优化技术，顾名思义，使用列的前缀代替整个列作为Key，当前缀长度合理时，既可以做到前缀索引的选择性接近全列索引，同时因为索引Key变短而减少索引文件的大小和维护开销。</p><p>想象一下存在如下业务场景，一张存放订单信息的基本表<code>order</code>，订单号长度为24位（如：61700123215824），表结构如下：</p><table><thead><tr><th>id</th><th>order_id</th></tr></thead><tbody><tr><td>1</td><td>61700123215824</td></tr><tr><td>2</td><td>61500280698102</td></tr><tr><td>3</td><td>61500280756582</td></tr></tbody></table><p>首先计算一下，全列索引选择性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="string">`order_id`</span>) / <span class="keyword">count</span>(*), <span class="number">2</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</div></pre></td></tr></table></figure><p>结果为1.00，选择前缀长度为5，看一下索引的选择性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="string">`order_id`</span>, <span class="number">5</span>)) / <span class="keyword">count</span>(*), <span class="number">2</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</div></pre></td></tr></table></figure><p>结果为0.00，5个字符长度的前缀，看来不行，我们增加到10，看一下索引的选择性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="string">`order_id`</span>, <span class="number">10</span>)) / <span class="keyword">count</span>(*), <span class="number">2</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</div></pre></td></tr></table></figure><p>结果为0.63，差强人意，我们继续以5位单位递增，看一下索引的选择性：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> <span class="keyword">round</span>(<span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">left</span>(<span class="string">`order_id`</span>, <span class="number">15</span>)) / <span class="keyword">count</span>(*), <span class="number">2</span>) <span class="keyword">from</span> <span class="string">`order`</span>;</div></pre></td></tr></table></figure><p>由于round的四舍五入，结果为1.00，那前缀能不能更少一些，在公司的业务系统内试了一下，前缀长度为11时，索引选择性为0.9999，四舍五入为1。通过夹逼的方法（😆默默的想起高数的夹逼定理），找到了最佳的索引前缀长度为11，接下来我们创建前缀索引：</p><blockquote><p>创建前缀索引</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">`order`</span> <span class="keyword">add</span> <span class="keyword">index</span> <span class="string">`idx_order_id`</span>(<span class="string">`order_id`</span>(<span class="number">11</span>));</div></pre></td></tr></table></figure><p><strong>注意：</strong> 前缀索引的缺点</p><ul><li>前缀索引不能用于order by与group by操作。</li><li>前缀索引不能用于covering index —— 显而易见，前缀索引并未包含<code>order_id</code>列的全部信息，所以并不能用于covering index。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;MySQL前缀索引&quot;&gt;&lt;a href=&quot;#MySQL前缀索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL前缀索引&quot;&gt;&lt;/a&gt;MySQL前缀索引&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt; 本文的所有优化仅针对InnoDB存储引擎。
      
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.nice-ai-life.com/categories/MySQL/"/>
    
      <category term="Index" scheme="https://blog.nice-ai-life.com/categories/MySQL/Index/"/>
    
    
      <category term="MySQL" scheme="https://blog.nice-ai-life.com/tags/MySQL/"/>
    
      <category term="Index" scheme="https://blog.nice-ai-life.com/tags/Index/"/>
    
  </entry>
  
  <entry>
    <title>高效率Shell</title>
    <link href="https://blog.nice-ai-life.com/2017/07/06/%E9%AB%98%E6%95%88%E7%8E%87Shell/"/>
    <id>https://blog.nice-ai-life.com/2017/07/06/高效率Shell/</id>
    <published>2017-07-06T05:52:12.000Z</published>
    <updated>2017-08-05T08:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>快速将开发分支代码合并至测试分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">export</span> DEV=dev</div></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">merge_dev</span></span>() &#123;</div><div class="line">    <span class="keyword">if</span> [ -z <span class="variable">$&#123;DEV&#125;</span> ]; <span class="keyword">then</span></div><div class="line">        <span class="keyword">if</span> [ -z <span class="variable">$1</span> ]; <span class="keyword">then</span></div><div class="line">            DEV=<span class="string">"dev"</span></div><div class="line">        <span class="keyword">else</span></div><div class="line">            DEV=<span class="variable">$1</span></div><div class="line">        <span class="keyword">fi</span></div><div class="line">    <span class="keyword">fi</span></div><div class="line">    BRANCH=$(git rev-parse --abbrev-ref HEAD)</div><div class="line">    git push origin <span class="variable">$&#123;BRANCH&#125;</span></div><div class="line">    git checkout <span class="variable">$&#123;DEV&#125;</span> \</div><div class="line">        &amp;&amp; git pull origin <span class="variable">$&#123;DEV&#125;</span> \</div><div class="line">        &amp;&amp; git merge <span class="variable">$&#123;BRANCH&#125;</span> -m <span class="string">"merge code automatically"</span> \</div><div class="line">        &amp;&amp; git push origin <span class="variable">$&#123;DEV&#125;</span> \</div><div class="line">        &amp;&amp; git checkout <span class="variable">$&#123;BRANCH&#125;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>统计工程代码行数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ./ -name <span class="string">"*.py"</span> -exec wc <span class="_">-l</span> &#123;&#125; \;|awk <span class="string">'BEGIN&#123;total=0&#125;&#123;print $1"\t"$2; $total+=$1&#125;END&#123;print "total lines: "$total&#125;'</span></div></pre></td></tr></table></figure><p>显示代码行最多的文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">find ./ -name <span class="string">"*.py"</span> | xargs -n 1 wc <span class="_">-l</span>|sort -nr</div></pre></td></tr></table></figure><p>显示处于<code>TIME_WAIT</code>的<code>SOCKET</code>个数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">netstat -n|awk <span class="string">'/^tcp/&#123;a[$6]++&#125;END&#123;for (j in a) print a[j], j&#125;'</span>|sort -nr|head -n 10</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;快速将开发分支代码合并至测试分支。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;co
      
    
    </summary>
    
      <category term="Bash" scheme="https://blog.nice-ai-life.com/categories/Bash/"/>
    
      <category term="Shell" scheme="https://blog.nice-ai-life.com/categories/Bash/Shell/"/>
    
    
      <category term="Shell" scheme="https://blog.nice-ai-life.com/tags/Shell/"/>
    
      <category term="Bash" scheme="https://blog.nice-ai-life.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>高效率Bash Shell快捷键</title>
    <link href="https://blog.nice-ai-life.com/2017/04/15/%E9%AB%98%E6%95%88%E7%8E%87Bash-Shell%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>https://blog.nice-ai-life.com/2017/04/15/高效率Bash-Shell快捷键/</id>
    <published>2017-04-14T16:47:59.000Z</published>
    <updated>2017-07-06T10:20:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><a href="https://keepalive555.github.io/2017/04/15/%E9%AB%98%E6%95%88%E7%8E%87Bash-Shell%E5%BF%AB%E6%8D%B7%E9%94%AE/" target="_blank" rel="external"><em>转载说明：本文章为作者原创，转载请标注原文地址</em></a></p><p>Bash Shell快捷键默认为Emacs编辑模式，与Emacs编辑器快捷键兼容，可通过<code>set -o vi</code>切换至vi编辑模式，通过<code>set -o emacs</code>切换回默认的Emacs编辑模式，本文所列快捷键均为Emacs模式下快捷键。</p><h5 id="特别注意："><a href="#特别注意：" class="headerlink" title="特别注意："></a><em>特别注意：</em></h5><blockquote><p>本人工作中一直使用Emacs编辑模式，Emacs编辑模式下的Alt键默认非Meta键（Emacs中使用频率很高的组合键），需要在终端中打开该项设置。</p></blockquote><h3 id="1-移动命令"><a href="#1-移动命令" class="headerlink" title="1.移动命令"></a>1.移动命令</h3><ul><li>Ctrl + a: 移动到命令行行首</li><li>Ctrl + e: 移动到命令行行尾</li><li>Ctrl + f: 向前移动一个字符</li><li>Ctrl + b: 向后移动一个字符</li><li>Alt + f: 向前移动一个单词</li><li>Alt + b: 向后移动一个单词</li></ul><h3 id="2-删除命令"><a href="#2-删除命令" class="headerlink" title="2.删除命令"></a>2.删除命令</h3><ul><li>Ctrl + u: 删除命令行行首至光标处的所有字符</li><li>Ctrl + k: 删除光标处至命令行行尾的所有字符</li><li>Ctrl + d: 删除光标处的字符</li><li>Ctrl + h: 删除光标前的字符</li><li>Ctrl + w: 删除光标处至单词词首的所有字符</li><li>Alt + d: 删除光标处至单词词尾的所有字符</li></ul><h3 id="3-编辑命令"><a href="#3-编辑命令" class="headerlink" title="3.编辑命令"></a>3.编辑命令</h3><ul><li>Ctrl + y: 粘贴至光标后</li><li>Ctrl + x Ctrl + u： 撤销上次编辑操作</li><li>Ctrl + x Ctrl + e: 启动编辑器编辑命令（<strong>注：可编辑字符较多的命令</strong>)</li></ul><h3 id="4-搜索历史命令"><a href="#4-搜索历史命令" class="headerlink" title="4.搜索历史命令"></a>4.搜索历史命令</h3><ul><li>Ctrl + r: 向后搜索历史命令（<strong>注：Ctrl + r可按多次，向后搜索历史命令</strong>）</li><li>Ctrl + g: 退出搜索模式</li><li>Ctrl + p: 上一条命令</li><li>Ctrl + n: 下一条命令</li></ul><h3 id="5-控制命令"><a href="#5-控制命令" class="headerlink" title="5.控制命令"></a>5.控制命令</h3><ul><li>Ctrl + l: 清屏（<strong>注：相当于clear命令</strong>)</li><li>Ctrl + c: 终止命令</li><li>Ctrl + z: 挂起命令</li></ul><h3 id="6-命令"><a href="#6-命令" class="headerlink" title="6.!命令"></a>6.!命令</h3><ul><li>!!: 执行上一条命令（<strong>注：执行$ls，后执行$!!，则会执行$ls</strong>）</li><li>!<prefix>: 执行最近执行的以<prefix>开头的命令</prefix></prefix></li></ul><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p>[1]: <a href="https://www.gnu.org/software/bash/manual/bash.html#Command-Line-Editing" target="_blank" rel="external">Bash官方手册</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://keepalive555.github.io/2017/04/15/%E9%AB%98%E6%95%88%
      
    
    </summary>
    
      <category term="Shell" scheme="https://blog.nice-ai-life.com/categories/Shell/"/>
    
      <category term="Bash" scheme="https://blog.nice-ai-life.com/categories/Shell/Bash/"/>
    
    
      <category term="Shell" scheme="https://blog.nice-ai-life.com/tags/Shell/"/>
    
      <category term="Bash" scheme="https://blog.nice-ai-life.com/tags/Bash/"/>
    
  </entry>
  
  <entry>
    <title>MySQL笔记</title>
    <link href="https://blog.nice-ai-life.com/2017/04/04/MySQL%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.nice-ai-life.com/2017/04/04/MySQL笔记/</id>
    <published>2017-04-04T06:24:23.000Z</published>
    <updated>2018-01-04T06:25:27.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%innodb_old_blocks_pct%'</span>; <span class="comment">-- 37%</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%innodb_buffer_pool_size%'</span>; <span class="comment">-- 显示InnoDB存储引擎BufferPool大小，134217728 = 128Mb</span></div><div class="line"><span class="comment">-- 热点数据</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%innodb_old_blocks_time%'</span>; <span class="comment">-- 1000ms, 位于midpoint处的数据在等待多长时间之后才会放入new热点数据。</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>; <span class="comment">-- 显示innodb引擎的状态</span></div><div class="line"><span class="comment">-- Modified db pages 指的是Flush list里面的DirtyPage</span></div><div class="line"><span class="comment">-- buffer pool hit rate</span></div><div class="line"><span class="keyword">select</span> pool_id, hit_rate, pages_made_young <span class="keyword">from</span> <span class="string">`information_schema`</span>.nnodb_buffer_pool_stats; <span class="comment">--</span></div><div class="line"><span class="keyword">select</span> *<span class="keyword">from</span> <span class="string">`information_schema`</span>.innodb_buffer_page_lru; <span class="comment">-- 查看innodb BufferPool中LRU list中具体Page信息。  </span></div><div class="line"><span class="keyword">select</span> *<span class="keyword">from</span> <span class="string">`information_schema`</span>.innodb_buffer_page_lru <span class="keyword">where</span> oldest_modification &gt; <span class="number">0</span>; <span class="comment">-- 查看DirtyPage</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%innodb_log_buffer_size%'</span>; <span class="comment">-- redo log buffer大小，默认为8MB，该缓冲区不需要太大，因为会被刷新至日志文件。   </span></div><div class="line"></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%innodb_fast_shutdown%'</span>; <span class="comment">-- SharpCheckpoint在Database关闭时将所有DirtyPage Flush回Disk，这是默认的工作方式。</span></div><div class="line"><span class="comment">-- FuzzyCheckpoint 进行部分页的刷新</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">engine</span> <span class="keyword">innodb</span> <span class="keyword">status</span>;</div><div class="line"></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'datadir'</span>; <span class="comment">-- datadir代表数据库所在目录</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>; <span class="comment">-- 显示master节点信息</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'binlog_cache_size'</span>; <span class="comment">-- binlo_cache_size mysql会为每一个Session开启一个binlog_cache，默认为32kB大小。</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">global</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'binlog_cache%'</span>; <span class="comment">-- Binlog_cache_use -&gt; 缓存使用次数，Binlog_cache_disk_use -&gt; 磁盘使用次数。</span></div><div class="line"></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'sync_binlog'</span>; <span class="comment">-- 二进制日志并不是在每次写的时候同步到磁盘（用户可以理解为缓冲写），因此数据所在操作系统挂机时，可能会有一部分数据没有写入二进制文件</span></div><div class="line"><span class="comment">-- sync_binlog = [N]，表示每写多少次就同步至磁盘sync_binlog = 1表示采用同步写磁盘的方式来写二进制日志。</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_support_xa'</span>; <span class="comment">-- 让mysql支持xa事务</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'binlog_format'</span>; <span class="comment">-- 指定binlog格式</span></div><div class="line"><span class="keyword">set</span> @@session.binlog_format = <span class="string">'ROW'</span>; <span class="comment">-- 修改会话级别binlog_format</span></div><div class="line"><span class="keyword">select</span> @@session.binlog_format; <span class="comment">-- ROW</span></div><div class="line"></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'socket'</span>; <span class="comment">-- mysqld监听的unix socket文件</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'pid_file'</span>; <span class="comment">-- mysqld的pid文件路径</span></div><div class="line"></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_data_file_path'</span>; <span class="comment">-- ibdata1:12M:autoextend 格式innodb_data_file_path=datafile_spec1[; datafile_spec2]...</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_file_per_table'</span>; <span class="comment">-- 为每个基于innodb存储引擎的表产生一个独立的表空间，命名规则为：</span></div><div class="line"> </div><div class="line"><span class="comment">-- innodb默认ib_logfile0, ib_logfile1是重做日志（redo log file）</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_log_file_size'</span>; <span class="comment">-- innodb redo log file size默认为512GB</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_log_files_in_group'</span>; <span class="comment">-- redo log group日志文件数量</span></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_log_group_home_dir'</span>;</div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_mirrored_log_groups'</span>;</div><div class="line"></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'innodb_flush_log_at_trx_commit'</span>; <span class="comment">-- 有效值为：0，1，2。0  - 当提交事务时，并不将事务的重做日志写入磁盘上的日志文件，而是等待主线程每秒的刷新。</span></div><div class="line"><span class="comment">-- 1 - 表示在执行commit时将重做日志缓冲同步写到磁盘，即伴有fsync的调用， 2 - 表示将重做日志写入磁盘，即写到文件系统的缓存中。</span></div><div class="line"></div><div class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%partition%'</span>;</div><div class="line"><span class="keyword">show</span> plugins;</div><div class="line"></div><div class="line"><span class="comment">-- mysql数据库支持以下几种类型的分区。range分区，list分区，hash分区，key分区。</span></div><div class="line"><span class="comment">-- range分区：行数据基于属于一个给定连续区间的列值被放入分区。</span></div><div class="line"><span class="comment">-- list</span></div><div class="line"><span class="comment">-- hash</span></div><div class="line"><span class="comment">-- key</span></div><div class="line"></div><div class="line"><span class="comment">-- innodb_file_pe_table</span></div><div class="line"><span class="comment">-- 表空间</span></div><div class="line"><span class="comment">-- ①数据②索引③插入缓冲Bitmap页</span></div><div class="line"></div><div class="line"><span class="comment">-- system ls /;</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Thrift教程</title>
    <link href="https://blog.nice-ai-life.com/2017/04/01/Thrift%E6%95%99%E7%A8%8B/"/>
    <id>https://blog.nice-ai-life.com/2017/04/01/Thrift教程/</id>
    <published>2017-03-31T16:21:27.000Z</published>
    <updated>2017-04-21T16:35:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Thrift简介"><a href="#1-Thrift简介" class="headerlink" title="1.Thrift简介"></a>1.Thrift简介</h2><p><a href="https://keepalive555.github.io/2017/04/01/Thrift%E6%95%99%E7%A8%8B/" target="_blank" rel="external"><em>转载说明：本文章为作者原创，转载请标注原文地址</em></a></p><p>Thrift由Facebook开发，解决了由不同语言编写的服务之间的调用问题。2009年Facebook将Thrift贡献给Apache基金会，成为一个开源项目。Thrift为典型的C/S架构，采用IDL(Interface Description Language)，定义接口。</p><p>Thrift提供了命令行工具thrift，根据指定的IDL定义文件，生成不同语言的代码。因Thrift的依赖比较多，所以建议读者，采用自己开发平台的包管理工具进行安装。本人平时在macOS下进行开发工作，采用brew install thrift，便可自动完成了thrift的安装。</p><h2 id="2-Thrift-IDL介绍"><a href="#2-Thrift-IDL介绍" class="headerlink" title="2.Thrift IDL介绍"></a>2.Thrift IDL介绍</h2><p>Thrift IDL的语法比较接近C++，熟悉C++的读者，可以迅速掌握Thrift IDL的语法。由于IDL语法上比较接近C++，所以Thrift IDL比较偏向于静态语言，Python、Ruby等动态语言开发者在使用IDL定义接口时需要特别注意。</p><p>Thrift IDL支持C/C++风格的“//”，“/*，*/”注释，也支持Python风格的”#”注释。</p><h3 id="1-基本数据类型"><a href="#1-基本数据类型" class="headerlink" title="1.基本数据类型"></a>1.基本数据类型</h3><ul><li>bool: A boolean value, true or false（<strong>注：布尔值</strong>)</li><li>byte: A signed byte（<strong>注：有符号字节</strong>）</li><li>i16: A 16-bit signed integer（<strong>注：16位有符号数</strong>）</li><li>i32: A 32-bit signed integer（<strong>注：32位有符号数</strong>）</li><li>i64: A 64-bit signed integer（<strong>注：64位有符号数</strong>）</li><li>double: A 64-bit floating point number（<strong>注：64位浮点数</strong>）</li><li>string: An encoding-agnostic text or binary string(<strong>注：编码无关的字符串</strong>）</li><li>void: Void (<strong>注：无返回值</strong>）</li></ul><h3 id="2-复合类型"><a href="#2-复合类型" class="headerlink" title="2.复合类型"></a>2.复合类型</h3><h4 id="1-struct"><a href="#1-struct" class="headerlink" title="1.struct"></a>1.struct</h4><p>struct——结构体类型，类似于C/C++中的结构体类型，将不同类型的数据聚合到一块儿。（<strong>注：描述面向对象语言中的类</strong>)。</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">struct User &#123;</div><div class="line">1: i32 id,</div><div class="line">2: string user_name,</div><div class="line">3: required bool is_admin,</div><div class="line">4: optional string nick_name,</div><div class="line">5: optional string sex = &quot;male&quot;,</div><div class="line">20: optional string city,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>注意：</strong> </p><ol><li>optional关键字标识该字段为可选的。</li><li>required关键字标识该字段为必填的。</li><li>定义中的序号，不可重复，但不是必须连续的。</li></ol><h4 id="2-enum"><a href="#2-enum" class="headerlink" title="2.enum"></a>2.enum</h4><p>enum枚举类型</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">enum UserType &#123;</div><div class="line">BLOCKED = 0,</div><div class="line">NORMAL = 1,</div><div class="line">ADMIN = 2,</div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="3-容器类型"><a href="#3-容器类型" class="headerlink" title="3.容器类型"></a>3.容器类型</h3><p>容器类型比较类似于C++ STL中的容器类型，Thrift提供了三种容器类型：list，map，set。</p><ul><li>list\<t\>: 由元素T组成的有序列表，Thrift将该容器类型编译为，C++ STL中的vector，Java中ArrayList，Python中list等等…</t\></li><li>set\<t\>: 无序的集合，Thrift将该容器类型编译为，C++ STL中的set，Java中的HashSet，Python中set等等…</t\></li><li>map\<t1, t2\="">: k-v映射，Thrift将该容器类型编译为，C++ STL中的map，Java中的HashMap，Python中的dict等等…</t1,></li></ul><h3 id="4-自定义类型"><a href="#4-自定义类型" class="headerlink" title="4.自定义类型"></a>4.自定义类型</h3><p>Thrift支持C/C++风格的，typedef关键字，用于声明自定义类型。</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">i32</span> Integer</div></pre></td></tr></table></figure><h3 id="5-异常"><a href="#5-异常" class="headerlink" title="5.异常"></a>5.异常</h3><p>Thrift支持自定义异常，语法同struct类型的定义相似，如下所示：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">exception NotFound &#123;</div><div class="line">1: string message,</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>注：在编写服务端代码时，仅仅在代码中抛出异常，是不够的，需要在定义接口时，指明该接口可能抛出的异常</strong></p><h3 id="6-服务"><a href="#6-服务" class="headerlink" title="6.服务"></a>6.服务</h3><p>Thrift IDL中的Service，与Java中的Interface有异曲同工之妙。Thrift定义服务的语法如下：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">service &lt;name&gt; &#123;</div><div class="line">&lt;returntype&gt; &lt;name&gt;(&lt;arguments&gt;)</div><div class="line">[throws (&lt;exceptions&gt;)]</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>定义一个获取用户的Service示例如下：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">service UserService &#123;</div><div class="line">User query_user(1: i32 user_id) throws (</div><div class="line">1: NotFound not_found),</div><div class="line">User add_user(1: User user);</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>注：service中接口定义之间的分割符号，可以是”，“，也可以是”；“。</strong></p><h3 id="7-命名空间"><a href="#7-命名空间" class="headerlink" title="7.命名空间"></a>7.命名空间</h3><p>Thrift支持C++风格的命明空间，等同于Java、Python中的package的概念。Thrift定义命名空间的语法如下：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">namespace</span> cpp com.example.project</div><div class="line"><span class="keyword">namespace</span> java com.example.project</div><div class="line"><span class="keyword">namespace</span> py com.example.project</div></pre></td></tr></table></figure><h2 id="3-Thrift使用方法"><a href="#3-Thrift使用方法" class="headerlink" title="3.Thrift使用方法"></a>3.Thrift使用方法</h2><p>示例文件：</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// filename: user.thrift</div><div class="line">namespace py thrift.rpc.user</div><div class="line"></div><div class="line">enum Sex &#123;</div><div class="line">FEMALE = 0,</div><div class="line">MALE = 1,</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct User &#123;</div><div class="line">1: string user_name,</div><div class="line">2: Sex sex,</div><div class="line">3: required i32 age,</div><div class="line">4: optional string city,</div><div class="line">&#125;</div><div class="line"></div><div class="line">exception NotFound &#123;</div><div class="line">1: string message,</div><div class="line">&#125;</div><div class="line"></div><div class="line">service UserService &#123;</div><div class="line">User query_user(1: i32 id) throws (</div><div class="line">1: NotFound not_found),</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>在Shell里面输入如下命令，生成Python代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thrift -out py --gen py:new_style,utf8strings,coding=utf-8</div></pre></td></tr></table></figure><p>--gen参数，指定待目标语言，冒号后以都好分割的为thrift为该语言提供的选项。</p><p>-out参数，指定thrift生成代码的存放路径（<strong>注：仅有一个-</strong>）</p><p>更详细的用法，可通过<code>thrift --help</code>获取。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>[1]<a href="https://thrift.apache.org/static/files/thrift-20070401.pdf" target="_blank" rel="external">Thrift官方手册</a></p><p>[2]<a href="https://diwakergupta.github.io/thrift-missing-guide/" target="_blank" rel="external">Thrift:The Missing Guide</a></p><p>[3]<a href="https://git-wip-us.apache.org/repos/asf?p=thrift.git;a=blob_plain;f=tutorial/tutorial.thrift" target="_blank" rel="external">Thrift官方示例</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-Thrift简介&quot;&gt;&lt;a href=&quot;#1-Thrift简介&quot; class=&quot;headerlink&quot; title=&quot;1.Thrift简介&quot;&gt;&lt;/a&gt;1.Thrift简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://keepalive555.github.i
      
    
    </summary>
    
      <category term="RPC" scheme="https://blog.nice-ai-life.com/categories/RPC/"/>
    
      <category term="Thrift" scheme="https://blog.nice-ai-life.com/categories/RPC/Thrift/"/>
    
    
      <category term="Python" scheme="https://blog.nice-ai-life.com/tags/Python/"/>
    
      <category term="Thrift" scheme="https://blog.nice-ai-life.com/tags/Thrift/"/>
    
  </entry>
  
  <entry>
    <title>MySQL分页</title>
    <link href="https://blog.nice-ai-life.com/2017/03/29/MySQL%E5%88%86%E9%A1%B5/"/>
    <id>https://blog.nice-ai-life.com/2017/03/29/MySQL分页/</id>
    <published>2017-03-29T14:49:42.000Z</published>
    <updated>2017-04-23T11:29:24.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://keepalive555.github.io/2017/03/29/MySQL%E5%88%86%E9%A1%B5/" target="_blank" rel="external"><em>转载说明：本文章为作者原创，转载请标注原文地址</em></a></p><p>公司最近上线了“订单管理系统”，系统内有比较多的分页展示逻辑，所以我单独拿出了点时间，对MySQL的分页做了总结。</p><p>提到MySQL分页，我们通常会首先考虑，使用偏移量offset+limit的办法实现。下面以实现目标：<br><strong>查询订单表<code>order</code>，并按订单创建时间<code>create_time</code>，降序排序，每页<code>50</code>条记录</strong><br>，为例进行说明。首先我们想到的sql语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> *<span class="keyword">from</span> <span class="string">`order`</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">`create_time`</span> <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">0</span>, <span class="number">50</span>;</div></pre></td></tr></table></figure><p>多次执行该操作，随着页数增加（<em>即：偏移量增大</em>），该查询语句的性能随之下降，耗时比较明显。当并发量上来时，这对MySQL数据库的压力是致命的。以翻页至200页为例，MySQL会查询<code>200 * 50</code>条记录，最后只返回<code>50</code>条记录，前面的<code>200 * (50 - 1)</code>条记录，将会被丢弃。</p><p>因为订单的属性很多，所以并无法为每一列建立索引（当然为每一列都建立索引，是简单粗暴的）。优化此类分页查询的一个最简单的办法，尽可能使用索引覆盖扫描，而不是查询所有列，然后在关联返回所需要的列。优化后的SQL语句如下所示：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> *<span class="keyword">from</span> <span class="string">`order`</span> <span class="keyword">inner</span> <span class="keyword">join</span> (<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> <span class="string">`order`</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">`create_time`</span> <span class="keyword">limit</span> <span class="keyword">desc</span> <span class="number">10000</span>, <span class="number">50</span>) <span class="keyword">as</span> <span class="string">`tmp`</span> <span class="keyword">using</span>(<span class="string">`id);</span></div></pre></td></tr></table></figure><p>这里MySQL扫描了尽可能少的页面，获取需要访问的记录后，然后再去关联查询，获取了所需的列，该种用法还存在若干类似的变种。</p><p>最后，也是我们确定的技术选型。推荐的用法，前端每次查询都传入上次查询记录的max_id，或者min_id传递给我们，然后根据id的索引去优化该操作。（<strong>注：只有id列的单调性与目标列的单调性一致时可采用该方案</strong>）产品设计上，我们不返回具体的页数，只提供了当前页，前后10页跳页的功能，解决了该问题。</p><p>向后翻页</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> *<span class="keyword">from</span> <span class="string">`order`</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">`create_time`</span> <span class="keyword">desc</span> <span class="keyword">where</span> <span class="string">`id`</span> &lt; min_id <span class="keyword">limit</span> <span class="number">50</span>;</div></pre></td></tr></table></figure><p>向前跳页</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> *<span class="keyword">from</span> <span class="string">`order`</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">`create_time`</span> <span class="keyword">desc</span> <span class="keyword">where</span></div><div class="line"><span class="string">`id`</span> &lt; min_id <span class="keyword">limit</span> <span class="number">450</span>, <span class="number">50</span>;</div></pre></td></tr></table></figure><p>向前翻页</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> *<span class="keyword">from</span> <span class="string">`order`</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">`create_time`</span> <span class="keyword">desc</span> <span class="keyword">where</span> <span class="string">`id`</span> &gt; max_id <span class="keyword">limit</span> <span class="number">50</span>;</div></pre></td></tr></table></figure><p>向后跳页</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> *<span class="keyword">from</span> <span class="string">`order`</span> <span class="keyword">order</span> <span class="keyword">by</span> <span class="string">`create_time`</span> <span class="keyword">desc</span> <span class="keyword">where</span> <span class="string">`id`</span> &gt; max_id <span class="keyword">limit</span> <span class="number">450</span>, <span class="number">50</span>;</div></pre></td></tr></table></figure><p>当数据库，采用分库分表，或者中间件时的分页操作，较为复杂，需要根据具体情况确定，本次不做陈述。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://keepalive555.github.io/2017/03/29/MySQL%E5%88%86%E9%A1%B5/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;转载说明：本文章为作者原创，转载请标注原文地址&lt;/e
      
    
    </summary>
    
      <category term="MySQL" scheme="https://blog.nice-ai-life.com/categories/MySQL/"/>
    
    
      <category term="MySQL" scheme="https://blog.nice-ai-life.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Vim实用技巧</title>
    <link href="https://blog.nice-ai-life.com/2017/03/20/Vim%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://blog.nice-ai-life.com/2017/03/20/Vim实用技巧/</id>
    <published>2017-03-20T02:06:09.000Z</published>
    <updated>2017-04-20T17:47:29.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://keepalive555.github.io/2017/03/20/Vim%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" target="_blank" rel="external"><em>转载说明：本文章为作者原创，转载请标注原文地址</em></a></p><p>本人是一个vim党，平时的开发工作都是在vim下完成的，但是…vim的官方手册就达2000多页，所以本人将平时遇到的一些比较有趣的插件与配置记录在配置文件中，一是方便他人借阅，分享一些实用的技巧，另一方面也是自我的慢慢积累。</p><h2 id="实用技巧"><a href="#实用技巧" class="headerlink" title="实用技巧"></a>实用技巧</h2><h3 id="1-显示代码中的Tab字符"><a href="#1-显示代码中的Tab字符" class="headerlink" title="1.显示代码中的Tab字符"></a>1.显示代码中的Tab字符</h3><blockquote><p>Python2.7版本，代码缩进是不允许空格与制表符Tab混合使用的,否则会抛出IndentationError异常，这困扰过很多初学者，明明看着缩进都对，但是就是报错。</p></blockquote><ul><li>使用正则表达式替换</li><li>开启list选项，查看Tab字符与空格，:set list。</li></ul><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">set</span> <span class="keyword">lcs</span>=<span class="keyword">ta</span><span class="variable">b:</span>&gt;-,trai<span class="variable">l:</span>-</div><div class="line"><span class="keyword">map</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;C-l&gt;</span> :<span class="keyword">let</span> &amp;<span class="keyword">list</span>=&amp;<span class="keyword">list</span>==<span class="number">1</span>?<span class="number">0</span>:<span class="number">1</span><span class="symbol">&lt;CR&gt;</span> <span class="comment">"也可通过:set list显示</span></div></pre></td></tr></table></figure><h3 id="2-在代码中插入表达式值"><a href="#2-在代码中插入表达式值" class="headerlink" title="2.在代码中插入表达式值"></a>2.在代码中插入表达式值</h3><blockquote><p>在开发工作中，经常需要输入一些常量值，因为数值比较大，不太容易计算的原因，很多同学直接输入了常量表达式。比如，存在时间戳t = int(time.time())，现在需要获取该时间戳24小时前的时间戳，可以这样写：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">_t = int(time.time()) - <span class="number">24</span> * <span class="number">3600</span></div></pre></td></tr></table></figure><blockquote><p>对于Python这种解释性语言来说，这种开销就落到了运行时，所以在vim中插入表达式值这个技巧显得比较实用。<br>在插入模式下（注意是插入模式），按下<c-r>，然后键入=，=后面输入需要计算的表达式，摁下Enter便可以计算出该表达式的值。</c-r></p></blockquote><h2 id="3-未配置插件，注释代码块"><a href="#3-未配置插件，注释代码块" class="headerlink" title="3.未配置插件，注释代码块"></a>3.未配置插件，注释代码块</h2><blockquote><p>有时候需要在服务器上修改一些配置，或者脚本，而服务器的vim未配置，没有代码注释插件，该怎么达到目的呢？这时，可以按下<c-v>进入列选择模式，选中需要注释代码的前几列，可通过o或O调整选择块的范围，然后按下I，输入注释符，Python中为’#’，然后按下<esc>，便可大功告成（注意：按下A则在块后面添加）。</esc></c-v></p></blockquote><h2 id="4-快速关闭文件"><a href="#4-快速关闭文件" class="headerlink" title="4.快速关闭文件"></a>4.快速关闭文件</h2><blockquote><p>大多数同学退出vim，都是在命令行下输入，:wq，退出，因为键位的缘故，个人感觉这样不是很方便，好在vim提供了更加便捷的方式。<br>关闭文件时，只需在普通模式下，输入ZZ，（即左侧shift+z，z按下两次），效果等同于:x命令，文件内容有改动，保存修改并退出，更改文件修改时间，如果文件未有改动则退出，不更改文件修改时间。</p><p>想要丢弃对文件的更改，大多数同学都是用，:q!，强制退出的。在vim中也可以在普通模式下输入ZQ，强制退出。</p></blockquote><h2 id="5-强制保存文件"><a href="#5-强制保存文件" class="headerlink" title="5.强制保存文件"></a>5.强制保存文件</h2><blockquote><p>注意：此用法需要当前用户，在sudoer文件中授权。</p><p>在工作中经常遇到，root用户的vim未进行任何配置，而用普通用户去编辑的时候，保存却没有权限的尴尬。下面的vim命令可以，调用sudo进行修改保存，非常实用。</p></blockquote><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="keyword">w</span> !sudo tee %</div></pre></td></tr></table></figure><h2 id="6-快速选择代码段落"><a href="#6-快速选择代码段落" class="headerlink" title="6.快速选择代码段落"></a>6.快速选择代码段落</h2><blockquote><p>常见选择方式：v - 选择字符，V - 行选择，<c-v> - 列选择。</c-v></p><p>大多数同学，进行多行代码选择时会用V开启行选择，然后通过j，k，o选择，代码块，或者是g跳转等，这样子虽然速度不慢，但是还是不够优雅。</p><p>vim中有个段落的概念（paragraphs），大家可以通过:tab help paragraphs，查看paragraphs的描述，或者该<a href="http://blog.carbonfive.com/2011/10/17/vim-text-objects-the-definitive-guide/" target="_blank" rel="external">博客</a><br>在开发工作中，我习惯将不同小功能，用空格划分为不同段落（Python开发中，这也是Pep8建议的），然后用段落移动命令，在段落间移动，用vip命令选择整个段落，很方便。</p></blockquote><table><thead><tr><th>命令</th><th>效果</th></tr></thead><tbody><tr><td>]]</td><td>foo</td><td></td></tr><tr><td>[[</td><td>bar</td><td></td></tr><tr><td>)</td><td>向前移动一条一语句（forward）</td><td></td></tr><tr><td>(</td><td>向后移动一条语句（backward）</td><td></td></tr><tr><td>{</td><td>向前移动至下一段落</td><td></td></tr><tr><td>}</td><td>向后移动至下一段落</td><td></td></tr><tr><td>vap</td><td>选择一个段落</td><td></td></tr><tr><td>vip</td><td>选择一个段落</td><td></td></tr></tbody></table><h2 id="7-设置vim分词"><a href="#7-设置vim分词" class="headerlink" title="7.设置vim分词"></a>7.设置vim分词</h2><blockquote><p>在vim中，用w,b,e,ge,等可以在单词之前移动，这种移动方式，大大方便了我们的编程，但是也有一些不尽如人意的地方，比如，下面的函数foo，有a，b，c三个参数，想要把光标从a移动至b，则需要输入2w，（vim将逗号，作为一个单词），这样子不是很方便（用习惯的同学除外），vim有个iskeyword选项，定义了“单词”的组成字符，可以将“，”，“.”，做为单词的一部分，下次移动的时候直接按下w便可从参数a，移动至参数b。（个人习惯，不喜勿喷^_^）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(a, b, c)</span>:</span></div><div class="line"><span class="keyword">pass</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span><span class="params">(object)</span>:</span></div><div class="line"><span class="keyword">pass</span></div><div class="line">d = Demo()</div><div class="line">d.__name__</div></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">:<span class="keyword">set</span> iskeyword+=\,</div><div class="line">:<span class="keyword">set</span> iskeyword+=\.</div></pre></td></tr></table></figure><p>或</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">:<span class="keyword">set</span> iskeyword+=\,\.</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://keepalive555.github.io/2017/03/20/Vim%E5%AE%9E%E7%94%
      
    
    </summary>
    
      <category term="Vim" scheme="https://blog.nice-ai-life.com/categories/Vim/"/>
    
    
      <category term="Vim" scheme="https://blog.nice-ai-life.com/tags/Vim/"/>
    
  </entry>
  
  <entry>
    <title>Shell实用技巧</title>
    <link href="https://blog.nice-ai-life.com/2017/03/19/Shell%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://blog.nice-ai-life.com/2017/03/19/Shell实用技巧/</id>
    <published>2017-03-19T15:55:16.000Z</published>
    <updated>2017-04-22T16:08:53.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://keepalive555.github.io/2017/03/19/Shell%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/" target="_blank" rel="external"><em>转载说明：本文章为作者原创，转载请标注原文地址</em></a></p><h3 id="1-获取当前Shell脚本文件所在目录"><a href="#1-获取当前Shell脚本文件所在目录" class="headerlink" title="1.获取当前Shell脚本文件所在目录"></a>1.获取当前Shell脚本文件所在目录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">PREFIX=$(<span class="built_in">cd</span> `dirname <span class="variable">$0</span>`; <span class="built_in">pwd</span>)</div></pre></td></tr></table></figure><h3 id="2-SSH开启密钥登录"><a href="#2-SSH开启密钥登录" class="headerlink" title="2.SSH开启密钥登录"></a>2.SSH开启密钥登录</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh user@host <span class="string">'mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys'</span> &lt; ~/.ssh/id_rsa.pub</div></pre></td></tr></table></figure><h3 id="3-SSH端口转发"><a href="#3-SSH端口转发" class="headerlink" title="3.SSH端口转发"></a>3.SSH端口转发</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nohup  /usr/bin/ssh -N -L 0.0.0.0:8000:10.10.10.10:12000 sa.demo.com &amp;</div></pre></td></tr></table></figure><h3 id="4-iOS证书转换"><a href="#4-iOS证书转换" class="headerlink" title="4.iOS证书转换"></a>4.iOS证书转换</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl pkcs12 -in demo.p12 -out demo.pem -nodes</div></pre></td></tr></table></figure><h3 id="5-统计代码行数"><a href="#5-统计代码行数" class="headerlink" title="5.统计代码行数"></a>5.统计代码行数</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ls *.py|xargs -n 1 wc <span class="_">-l</span>|awk <span class="string">'BEGIN&#123;total=0&#125;&#123;$total+=$1&#125;END&#123;print "total lines:\t"$total&#125;'</span></div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://keepalive555.github.io/2017/03/19/Shell%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;em&gt;转载说明：本文
      
    
    </summary>
    
      <category term="Shell" scheme="https://blog.nice-ai-life.com/categories/Shell/"/>
    
    
      <category term="Shell" scheme="https://blog.nice-ai-life.com/tags/Shell/"/>
    
  </entry>
  
  <entry>
    <title>Kafka常见操作</title>
    <link href="https://blog.nice-ai-life.com/2017/01/05/Kafka%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/"/>
    <id>https://blog.nice-ai-life.com/2017/01/05/Kafka常见操作/</id>
    <published>2017-01-04T16:35:26.000Z</published>
    <updated>2018-01-04T16:44:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Kafka常见操作命令行集锦"><a href="#Kafka常见操作命令行集锦" class="headerlink" title="Kafka常见操作命令行集锦"></a><code>Kafka</code>常见操作命令行集锦</h2><p><strong><em>导出变量定义：</em></strong> <code>$ZK_HOSTS</code>定义在<code>~/.bashrc</code>中的导出变量，为<code>Zookeeper</code>集群地址</p><blockquote><p>查看Kafka Cluster中的topic</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --list --zookeeper <span class="variable">$ZK_HOSTS</span></div></pre></td></tr></table></figure><blockquote><p>查看Kafka某个topic的信息</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --describe --topic benchmark --zookeeper <span class="variable">$ZK_HOSTS</span></div></pre></td></tr></table></figure><blockquote><p>新建一个1个partition的topic readbench</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --create --topic readbench --partitions 1 --replication-factor 1 --zookeeper <span class="variable">$ZK_HOSTS</span></div></pre></td></tr></table></figure><blockquote><p>新建一个1分区，复制因子为1的topic</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --create --topic name --partitions 1 --replication-factor 1 --zookeeper <span class="variable">$ZK_HOSTS</span></div></pre></td></tr></table></figure><blockquote><p>新建一个5分区，复制因子为1的topic</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --create --topic name --partitions 5 --replication-factor 1 --zookeeper <span class="variable">$ZK_HOSTS</span></div></pre></td></tr></table></figure><blockquote><p>以group_name为消费组消费名称为name的topic中的数据</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-console-consumer.sh --topic name --partition 0 --consumer-property group.id=group_name --from-beginning --bootstrap-server 10.95.134.86:9092,10.95.134.86:9093,10.95.134.86:9094</div></pre></td></tr></table></figure><blockquote><p>往topic name中生产数据</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bin/kafka-console-producer.sh --broker-list 10.95.134.86:9092,10.95.134.86:9093,10.95.134.86:9094 --sync --topic name</div></pre></td></tr></table></figure><blockquote><p>物理删除kafka中的一个topic（kafka默认是逻辑删除）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --delete --topic name --zookeeper $ZK_HOSTS</div></pre></td></tr></table></figure><ul><li>删除掉<code>Zookeeper</code>集群中<code>name</code>标识的<code>topic</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/zkCli.sh rmr /brokers/topics/name</div></pre></td></tr></table></figure><blockquote><p><code>Kafka</code>中为topic增加partition（不能够删除partition，仅支持增加）</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --alter --topic name --zookeeper <span class="variable">$ZK_HOSTS</span> --partitions 3</div></pre></td></tr></table></figure><blockquote><p> Kafka中为topic更新配置参数</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-topics.sh --alter --topic readbench --zookeeper <span class="variable">$ZK_HOSTS</span> --config cleanup.policy=delete</div></pre></td></tr></table></figure><blockquote><p>Kafka集群中添加新的broker时，需要将一些topic的存储压力分散到新的broker上去，这时需要kafka reassign工具，分三步操作</p><ul><li>1、指定待迁移的topic，以json格式存放在topic-to-move.json文件中。</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">cat &gt;&gt; topics-to-move.json &lt;&lt; EOF</div><div class="line">&#123;</div><div class="line">    <span class="string">"topics"</span>: [</div><div class="line">        &#123;<span class="string">"topic"</span>: <span class="string">"name1"</span>&#125;,</div><div class="line">        &#123;<span class="string">"topic"</span>: <span class="string">"name2"</span>&#125;,</div><div class="line">    ],</div><div class="line">    <span class="string">"version"</span>: 1</div><div class="line">&#125;</div><div class="line">EOF</div></pre></td></tr></table></figure><ul><li>2、生成移动脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-reassign-partitions.sh --zookeeper <span class="variable">$ZK_HOSTS</span> --topics-to-move-json-file topic-to-move.json --broker-list <span class="string">"1,2"</span> --generate</div></pre></td></tr></table></figure><p>将输出信息中的Proposed partition reassignment configuration一栏下的json字符串保存为reassign.json文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">'&#123;"version":1,"partitions":[&#123;"topic":"readbench","partition":0,"replicas":[3]&#125;]&#125;'</span> &gt;&gt; reassign.json</div></pre></td></tr></table></figure><ul><li>3、执行迁移脚本</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/kafka-reassign-partitions.sh --zookeeper <span class="variable">$ZK_HOSTS</span> --reassignment-json-file reassign.json --execute</div></pre></td></tr></table></figure><ul><li>4、查看迁移进度</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/bin/kafka-reassign-partitions.sh --zookeeper <span class="variable">$ZK_HOSTS</span> --reassignment-json-file reassign.json --verify</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Kafka常见操作命令行集锦&quot;&gt;&lt;a href=&quot;#Kafka常见操作命令行集锦&quot; class=&quot;headerlink&quot; title=&quot;Kafka常见操作命令行集锦&quot;&gt;&lt;/a&gt;&lt;code&gt;Kafka&lt;/code&gt;常见操作命令行集锦&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
