<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="枫叶居" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="技术博客">
<meta property="og:type" content="website">
<meta property="og:title" content="枫叶居">
<meta property="og:url" content="https://blog.nice-ai-life.com/index.html">
<meta property="og:site_name" content="枫叶居">
<meta property="og:description" content="技术博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="枫叶居">
<meta name="twitter:description" content="技术博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.nice-ai-life.com/"/>





  <title> 枫叶居 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <a href="https://github.com/keepalive555" class="github-corner" aria-label="View source on Github"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#fff; color:#151513; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">枫叶居</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description">桃李春风一杯酒，江湖夜雨十年灯</h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2020/09/24/长尾请求/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/24/长尾请求/" itemprop="url">
                  长尾请求与分位时
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-24T00:44:18+08:00">
                2020-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文章为笔者原创，转载需要表明出处！！！</p>
<p>QA同学在线上测试重构后的<strong>golang模块</strong>时发现，会偶现后端响应<strong>超时</strong>的现象。在之前的压测中，接口监控<strong>响应</strong>稳定在50ms左右，所以猜测存在<strong>长尾请求</strong>。</p>
<h1 id="目前问题"><a href="#目前问题" class="headerlink" title="目前问题"></a>目前问题</h1><h2 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h2><p>目前业务监控系统，反应接口耗时的系统指标为——<strong>平响</strong>，即平均响应时间=<strong>单位时间内所有请求耗时总和/请求数</strong>。</p>
<p>平均数并不能够反应数据的波动情况，例如：请求a耗时10ms（记为cost(a)=10ms），请求b耗时300ms（记为cost(b)=300ms），请求a与请求b的平均响应时间= cost(a, b) = (cost(a) + cost(b)) / 2 =<strong>155ms</strong> 。平均耗时155ms（&lt;=200ms）是达标的，但是请求b耗时300ms明显是未达标的。</p>
<p>APP后端研发工程师，都了解对端接口请求耗时<strong>200ms</strong>是一个临界阈值——请求耗时200ms以下，用户对网络延迟几乎无感，体验较好，请求耗时200ms以上，网络延迟感明显，用户体验较差。因此请求耗时是否<strong>&lt;=200ms</strong>经常作为接口性能优化的判断条件之一。在业务中，经常会遇到<strong>命中缓存</strong>与<strong>未命中缓存</strong>时耗时差距较大的场景，<strong>所以平响无法全面的衡量系统的性能</strong>。</p>
<h2 id="长尾请求"><a href="#长尾请求" class="headerlink" title="长尾请求"></a>长尾请求</h2><p>业界关于延迟有一个常用的<a href="https://stackoverflow.com/questions/12808934/what-is-p99-latency" target="_blank" rel="external">P99标准</a>，即99％的请求应该比指定的延迟更小，仅允许1％的请求大于指定的延迟，这1%的请求即为”长尾请求”。打个形象的比喻，班级内99%同学的成绩都非常优秀，但总会有几位同学拖班级平均成绩后腿儿，拉低班级的“平均分，这几位同学就是“长尾请求”。</p>
<p>长尾请求的产生原因是多种多样的且复杂的，包括实现方式、系统因素、硬件因素等等，在分布式中常见原因如下：</p>
<ul>
<li>依赖的下游服务有波动；</li>
<li>资源竞争（包括：文件、锁、硬件资源）；</li>
<li>网络波动；</li>
<li>机器负载较大，系统调度，排队；</li>
<li>fullGC;</li>
<li>CPU降低功率控制温度；</li>
</ul>
<p>有关长尾请求更多介绍于技术优化思路，参考Google Jeff Dean大神的论文：<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.732.6087&amp;rep=rep1&amp;type=pdf。" target="_blank" rel="external">http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.732.6087&amp;rep=rep1&amp;type=pdf。</a></p>
<p>长尾请求在某种意义上来讲是无法消除的，但是我们可以通过技术手段将长尾请求控制在一定的比例之内，<strong>因此长尾请求也是很多性能优化工作的关注重点</strong>。由于长尾请求的存在，<strong>平响</strong>指标无法很好的反应绝大多数请求的耗时情况，因此有了<strong>分位时</strong>的概念，通俗的理解就是xx%的耗时在多少之内。</p>
<h2 id="分位时"><a href="#分位时" class="headerlink" title="分位时"></a>分位时</h2><p>分位数，是统计学的一个术语，概念如下：</p>
<blockquote>
<p>百分位数又称百分位分数（percentile），是一种相对地位量数，它是次数分布（Frequency Distribution，频数分布）中的一个点。把一个次数分布排序后，分为 100 个单位，百分位数就是次数分布中相对于某个特定百分点的原始分数，它表明在次数分布中特定个案百分比低于该分数。</p>
</blockquote>
<p>通俗的讲，<strong>将数据按照升序排列，等分为100份，在P=0.9（即99%）位置的数是多少</strong>。例如：全校800名学生，80分位数，指80%的学生考分在多少分以上，我们可以这样计算：</p>
<ol>
<li>将800名学生成绩，按照从高到低的降序排列；</li>
<li>800名同学80%的名次为：800 * 80% = 640；</li>
<li>全校成绩排名第640名的学生成绩即我们所需的80分位数；</li>
</ol>
<p>现实中，存在<code>total（总数） * percent（百分比）</code>为浮点数的情况，例如9名学生的分数分别为：100,88,89,90,95,70,65,78,79，求90分位数，按照上述思路来计算：</p>
<ol>
<li>将9名学生成绩，按照从高到低的升序排列为：100, 95, 90, 89, 88, 79, 78, 70, 65;</li>
<li>9名同学90%的名次为：9 * 90% = 8.1;</li>
</ol>
<p>问题来了，第8.1名学生的成绩为多少？显然不存在第8.1名学生，假如存在的话，那么第8.1名学生的成绩一定在第8名与第9名之间。拆开来看，第8.1名学生成绩等价于在第8名学生成绩基础上，加上第9名与第8名成绩之差乘以10%=score(8)+(score(9)-score(8))*10% = 70 + (65 - 70)*10% =69.50，即这9名学生的90分位数为69.50分（注意：假设第9名与第8名成绩区间是分布均匀的，实际上样本数量较少时波动比较大，随着样本数量变大趋向于均匀）。</p>
<p>总结分位数计算规则如下：</p>
<ol>
<li>将输入数组升序/降序排列，数组长度为n；</li>
<li>求数组[0, n)的P%的下标，m = n*P% - 1 = i + j，i代表整数部分，j代表小数部分；</li>
<li>求下标为m的元素值 f(m) = f(i) + (f(j) - f(i)) * j；</li>
</ol>
<p>参考上述，可得分位时，是将所有请求耗时由小至大升序排列，求得分位数。计算分位时的Python脚本代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="string">'''</span></div><div class="line">分位时</div><div class="line">@Author: wanglanwei</div><div class="line">@Date: 2020-09-24</div><div class="line">@Time: 00:35:25</div><div class="line">@Email: the.matrix.vvv@gmail.com or luckydreamcatcher@163.com</div><div class="line">'''</div><div class="line"></div><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">percentile</span><span class="params">(simples, p)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    计算分位时</div><div class="line">    Args:</div><div class="line">        simples: 样本数组</div><div class="line">        p: 百分比</div><div class="line">    Returns:</div><div class="line">        分位数</div><div class="line">    '''</div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> simples <span class="keyword">or</span> <span class="keyword">not</span> p:</div><div class="line">        <span class="keyword">return</span> <span class="number">0.0</span></div><div class="line">    simples.sort()</div><div class="line">    n = len(simples)</div><div class="line">    rank = n*p - <span class="number">1</span></div><div class="line">    i = int(rank)</div><div class="line">    j = rank - i</div><div class="line">    <span class="keyword">return</span> simples[i] + (simples[i+<span class="number">1</span>] - simples[i]) * j</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_data</span><span class="params">(f)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    从文件f中读取输入</div><div class="line">    Args:</div><div class="line">        f: 输入，包括标准输入、文件、网络等等</div><div class="line">    Returns:</div><div class="line">        样本数组</div><div class="line">    '''</div><div class="line">    res = []</div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        num = f.readline().strip(<span class="string">'\n'</span>)</div><div class="line">        <span class="keyword">if</span> <span class="keyword">not</span> num <span class="keyword">or</span> num == <span class="string">'EOF'</span>:</div><div class="line">            <span class="keyword">break</span></div><div class="line">        res.append(float(num))</div><div class="line">    <span class="keyword">return</span> res</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    <span class="comment"># 读取百分比p</span></div><div class="line">    p = <span class="number">90</span></div><div class="line">    <span class="keyword">if</span> len(sys.argv) &gt; <span class="number">1</span>:</div><div class="line">        p = int(sys.argv[<span class="number">1</span>])</div><div class="line">    p = float(p) / <span class="number">100</span></div><div class="line">    <span class="comment"># 从标准输出读取样本</span></div><div class="line">    simples = read_data(sys.stdin)</div><div class="line">    result = percentile(simples, p)</div><div class="line">    <span class="keyword">print</span> <span class="string">"percentile&lt;%.2f&gt;: %.2f"</span> % (p, result)</div></pre></td></tr></table></figure>
<p>这样求一批请求的耗时的99分位时，Linux示例命令如下:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cat service.log|grep -o -P <span class="string">"cost\[\d+(\.|\])?"</span>|grep -o -P <span class="string">"\d+"</span>|./stat.py</div></pre></td></tr></table></figure>
<p>在笔者的案例中，抓取生产环境日志约10w条，求得重构后<code>golang</code>接口，99.9分位时约为200ms，平响为10ms，差距是要比想想中的要大的多。所以关注系统性能指标不只需要关注<strong>平响</strong>，也需要关注<strong>分位时</strong>。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.732.6087&amp;rep=rep1&amp;type=pdf" target="_blank" rel="external">The tail at scale</a></p>
<p><a href="https://juejin.im/post/6844903904371539975" target="_blank" rel="external">经典分布式论文阅读：The Tail at Scale</a></p>
<p><a href="https://baike.baidu.com/item/%E7%99%BE%E5%88%86%E4%BD%8D%E6%95%B0/10064171?fr=aladdin" target="_blank" rel="external">百分位数</a></p>
<p><a href="https://www.cnblogs.com/liuning8023/p/3531900.html" target="_blank" rel="external">分位数</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2020/09/20/Golang性能分析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2020/09/20/Golang性能分析/" itemprop="url">
                  Golang性能分析
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-09-20T16:47:49+08:00">
                2020-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/性能优化/" itemprop="url" rel="index">
                    <span itemprop="name">性能优化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[toc]</p>
<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本文章为笔者原创，转载需要表明出处！！！</p>
<p>笔者最近在做<strong>golang重构旧php模块</strong>的事情，PHP模块峰值请求约1.5w QPS，是典型的高并发场景，重构过程中，代码中一些容易被开发者<strong>“选择性忽略”</strong>的问题会被指数级放大，比如内存泄露、full GC等等，所以<strong>上线/放量</strong>前必须进行压力测试。</p>
<p>为了更贴近生产环境，与QA同学合作，将重构后的golang模块部署到生产集群，选择一台20标准CPU核的实例，从服务列表中摘除，做压力测试。预期单实例的配置，可以扛住400QPS，在压力测试过程中发现，并发达到400QPS时，实例CPU使用率达到100%，成为性能瓶颈。</p>
<p><strong>节约机器资源作为golang重构旧php的重要收益之一</strong>，为了达成此目标，笔者必须解决golang模块的cpu性能瓶颈，达到预期性能。</p>
<h1 id="CPU性能分析"><a href="#CPU性能分析" class="headerlink" title="CPU性能分析"></a>CPU性能分析</h1><p>CPU性能分析，又称为CPU Profiling，下面介绍了三种笔者常用的性能分析手段：</p>
<ul>
<li>go tool pprof命令行工具</li>
<li>go tool pprof可视化工具</li>
<li>FlameGraph火焰图</li>
</ul>
<p>go tool pprof工具非常强大，性能分析不止这三中方式，可根据业务场景自由选择。实践中，笔者推荐使用<code>go tool pprof</code>与<code>Flame Graph</code>两种方式相结合。</p>
<p>为了在不影响阅读的前提下，保证服务安全，文章的敏感信息，笔者均用”xxx”进行了替换。</p>
<h2 id="CPU-Profiling原理"><a href="#CPU-Profiling原理" class="headerlink" title="CPU Profiling原理"></a>CPU Profiling原理</h2><p><strong>借助工具进行CPU Profiling之前，我们需要了解CPU Profiling的基本原理，这样才可以对数据做出更准确的判断</strong>。然而许许多多Google搜索到的技术博客，几乎千篇一律的都是在介绍golang pprof工具的使用。笔者在阅读golang <code>runtime/pprof</code>源码的基础上，借鉴了Linux <code>perf</code>工具的工作原理，说明一下。</p>
<p>Golang pprof默认会以100Hz（1秒100次）的频率，采集各个goroutine调用栈。假设函数<code>foo</code>在采样时，位于调用栈栈顶，则可以认为当前goroutine在执行<code>foo</code>函数，假如100次采样，<code>foo</code>函数30次位于调用栈栈顶，则可以认为<code>foo</code>函数执行消耗30%。了解了基本原理，下面我们便可以借助工具进行分析。</p>
<h2 id="Golang模块开启Profiling"><a href="#Golang模块开启Profiling" class="headerlink" title="Golang模块开启Profiling"></a>Golang模块开启Profiling</h2><p>Golang官方提供强大的<code>runtime/pprof</code>包，用于Golang程序的Profiling。<code>runtime/pprof</code>包功能强大，但对于需长久运行的服务，不够方便。在生产环境中，建议开启<code>http pprof</code>，通过Web服务提供Profiling数据，方便直接使用浏览器查看或其它分析工具拉取数据进行进一步分析。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> (</div><div class="line">  _ <span class="string">"net/http/pprof"</span></div><div class="line">)</div></pre></td></tr></table></figure>
<p><code>net/http/pprof</code>包<code>init</code>初始化函数会在默认<code>HTTP Server</code>注册几个路由，将<code>runtime/pprof</code>的输出包装为<code>http</code>服务的响应，逻辑比较简单，可以参考阅读<code>net/http/pprof</code>包源码，此处不做赘述。</p>
<h2 id="go-tool-pprof命令行工具"><a href="#go-tool-pprof命令行工具" class="headerlink" title="go tool pprof命令行工具"></a>go tool pprof命令行工具</h2><p>采用Golang自带的pprof命令行工具，进行CPU性能分析：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go tool pprof http://xxxx.baidu.com:2021/debug/pprof/profile?seconds=120</div></pre></td></tr></table></figure>
<p>go tool pprof会将服务端http响应数据写入本地文件（本地文件默认存储<code>/root/pprof</code>目录下，输入go tool pprof  <filepath>即可分析本地文件），运行2min之后，自动进入交互式命令行，使用<code>top</code>命令即可查看CPU耗时排行：</filepath></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(pprof) top</div><div class="line">Showing nodes accounting <span class="keyword">for</span> 18.09s, 35.20% of 51.39s total</div><div class="line">Dropped 856 nodes (cum &lt;= 0.26s)</div><div class="line">Showing top 10 nodes out of 246</div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">     3.20s  6.23%  6.23%      3.58s  6.97%  syscall.Syscall</div><div class="line">     2.43s  4.73% 10.96%     10.65s 20.72%  runtime.mallocgc</div><div class="line">     2.06s  4.01% 14.96%      2.10s  4.09%  encoding/json.stateInString</div><div class="line">     2.02s  3.93% 18.89%      3.97s  7.73%  runtime.scanobject</div><div class="line">     1.61s  3.13% 22.03%      4.76s  9.26%  encoding/json.checkValid</div><div class="line">     1.43s  2.78% 24.81%      1.43s  2.78%  runtime.usleep</div><div class="line">     1.39s  2.70% 27.52%      5.18s 10.08%  runtime.mapassign_faststr</div><div class="line">     1.36s  2.65% 30.16%      1.67s  3.25%  encoding/json.unquoteBytes</div><div class="line">     1.30s  2.53% 32.69%      1.45s  2.82%  net/url.unescape</div><div class="line">     1.29s  2.51% 35.20%      1.86s  3.62%  encoding/json.(*decodeState).rescanLiteral</div></pre></td></tr></table></figure>
<p>标注：</p>
<ul>
<li>flat: 函数（不包含子函数）执行耗时；</li>
<li>flat%：函数执行耗时占抽样时间百分比；</li>
<li>sum%: 此<strong>行</strong>（包括）之前，flat%之和；</li>
<li>cum: 函数（包含调用的子函数）执行耗时；</li>
<li>cum%:  函数（包含调用的子函数）的执行耗时占抽样时间百分比；</li>
</ul>
<p>top命令默认显示前10条数据，按照flat列降序排列。<strong>虽然定位了CPU耗时较高的函数，但是粒度较细，并不能直观反应产生性能瓶颈的代码</strong>。可以指定<code>-cum</code>参数，显示函数累加执行耗时排行，键入命令<code>top20 -cum</code>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">(pprof) top20 -cum</div><div class="line">Showing nodes accounting <span class="keyword">for</span> 0.61s, 1.19% of 51.39s total</div><div class="line">Dropped 856 nodes (cum &lt;= 0.26s)</div><div class="line">Showing top 20 nodes out of 246</div><div class="line">      flat  flat%   sum%        cum   cum%</div><div class="line">     0.04s 0.078% 0.078%     41.26s 80.29%  net/http.(*conn).serve</div><div class="line">     0.04s 0.078%  0.16%     38.25s 74.43%  github.com/gin-gonic/gin.(*Context).Next</div><div class="line">     0.03s 0.058%  0.21%     38.24s 74.41%  icode.baidu.com/baidu/gdp/gdp.WebHandlerFunc.toG<span class="keyword">in</span>HandlerFunc.func1</div><div class="line">         0     0%  0.21%     38.17s 74.28%  github.com/gin-gonic/gin.(*Engine).handleHTTPRequest</div><div class="line">         0     0%  0.21%     38.06s 74.06%  github.com/gin-gonic/gin.(*Engine).ServeHTTP</div><div class="line">         0     0%  0.21%     37.96s 73.87%  net/http.serverHandler.ServeHTTP</div><div class="line">     0.01s 0.019%  0.23%     36.86s 71.73%  github.com/gin-gonic/gin.RecoveryWithWriter.func1</div><div class="line">         0     0%  0.23%     36.86s 71.73%  icode.baidu.com/baidu/gdp/gdp.ginHandler2WebHandler.func1</div><div class="line">     0.07s  0.14%  0.37%     36.80s 71.61%  icode.baidu.com/baidu/gdp/gdp.ShoubaiTowerLogware</div><div class="line">         0     0%  0.37%     32.46s 63.16%  icode.baidu.com/baidu/gdp/gdp.recovery</div><div class="line">     0.01s 0.019%  0.39%     32.45s 63.14%  icode.baidu.com/baidu/xxxxxx/xxxxloc/middlewares.Recovery</div><div class="line">     0.03s 0.058%  0.45%     32.41s 63.07%  icode.baidu.com/baidu/xxxxxx/xxxxloc/middlewares.PProfAuth</div><div class="line">         0     0%  0.45%     31.95s 62.17%  icode.baidu.com/baidu/xxxxxx/xxxxloc/middlewares.ParseParams</div><div class="line">     0.04s 0.078%  0.53%     30.18s 58.73%  icode.baidu.com/baidu/xxxxxx/xxxxloc/controllers.(*WeatherController).GetIndexWeather</div><div class="line">     0.04s 0.078%   0.6%     27.44s 53.40%  icode.baidu.com/baidu/xxxxxx/xxxxloc/models/service/page/weather.(*WeatherIndexIphone).GetData</div><div class="line">     0.01s 0.019%  0.62%     25.48s 49.58%  icode.baidu.com/baidu/xxxxxx/xxxxloc/models/service/data/weather.(*DataWeatherCommon).GetWeatherData</div><div class="line">     0.02s 0.039%  0.66%     21.03s 40.92%  encoding/json.Unmarshal</div><div class="line">         0     0%  0.66%     16.16s 31.45%  encoding/json.(*decodeState).unmarshal</div><div class="line">     0.04s 0.078%  0.74%     16.16s 31.45%  encoding/json.(*decodeState).value</div><div class="line">     0.23s  0.45%  1.19%     16.15s 31.43%  encoding/json.(*decodeState).object</div></pre></td></tr></table></figure>
<p>由上可以观察到，系统执行流程大概包括了http框架、controller层、page层、data层，符合调用堆栈。encoding/json.Unmarshal函数累积执行耗时占总样本百分比为<strong>40.92%</strong>，很明显不合理，是系统<strong>性能瓶颈</strong>。go tool pprof命令行工具使用简单方便，无需要借助工具，但是表达不直观，我们可以借助下面提到的两种方式——以图或火焰图的形式。</p>
<h2 id="go-tool-pprof可视化工具"><a href="#go-tool-pprof可视化工具" class="headerlink" title="go tool pprof可视化工具"></a>go tool pprof可视化工具</h2><p>go tool pprof命令行支持-png、-svg、-pdf等选项，输出png图片、svg图片、pdf文档。go tool pprof此功能依赖graphviz组件。</p>
<h3 id="安装graphviz"><a href="#安装graphviz" class="headerlink" title="安装graphviz"></a>安装graphviz</h3><p>graphviz组件依赖较多，建议解决各个linux发行版本的包管理器进行安装，源码安装参考官方：<a href="http://www.graphviz.org/download/source/。" target="_blank" rel="external">http://www.graphviz.org/download/source/。</a></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># debian</span></div><div class="line">apt-get install -y graphviz</div><div class="line"><span class="comment"># macos</span></div><div class="line">brew install graphviz</div></pre></td></tr></table></figure>
<h3 id="导出图片"><a href="#导出图片" class="headerlink" title="导出图片"></a>导出图片</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go tool pprof -png http://xxxx.baidu.com:2021/debug/pprof/profile?seconds=120 &gt;&gt; profile.png</div></pre></td></tr></table></figure>
<h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><p>火焰图（FlameGraph）能直观的反映出系统的执行情况，是一种性能分析利器。Golang语言pprof工具暂不支持导出火焰图，需要安装第三方工具。笔者推荐使用由Uber开源的go-torch。</p>
<h3 id="安装FlameGraph分析工具"><a href="#安装FlameGraph分析工具" class="headerlink" title="安装FlameGraph分析工具"></a>安装FlameGraph分析工具</h3><p>安装go-torch：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go install github.com/uber/go-torch</div></pre></td></tr></table></figure>
<p>安装go-torch依赖——FlameGraph脚本:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 下载FlameGraph</span></div><div class="line">wget https://github.com/brendangregg/FlameGraph/archive/master.zip</div><div class="line"><span class="comment"># 解压</span></div><div class="line">unzip master.zip</div><div class="line"><span class="comment"># 移动至/opt目录</span></div><div class="line">sudo mv FlameGraph-master /opt/FlameGraph</div><div class="line"><span class="comment"># 添加至系统Path中</span></div><div class="line"><span class="built_in">echo</span> <span class="string">'export PATH=$PATH:/opt/FlameGraph'</span> |sudo tee <span class="_">-a</span> /etc/profile &amp;&amp; <span class="built_in">source</span> /etc/profile</div></pre></td></tr></table></figure>
<p>go-torch工具安装成功，运行<code>go torch --help</code>查看帮助信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">Usage:</div><div class="line">  go-torch [options] [binary] &lt;profile <span class="built_in">source</span>&gt;</div><div class="line"></div><div class="line">pprof Options:</div><div class="line">  -u, --url=         Base URL of your Go program (default: http://localhost:8080)</div><div class="line">      --suffix=      URL path of pprof profile (default: /debug/pprof/profile)</div><div class="line">  -b, --binaryinput= File path of previously saved binary profile. (binary profile is anything accepted by</div><div class="line">                     https://golang.org/cmd/pprof)</div><div class="line">      --binaryname=  File path of the binary that the binaryinput is <span class="keyword">for</span>, used <span class="keyword">for</span> pprof inputs</div><div class="line">  -t, --seconds=     Number of seconds to profile <span class="keyword">for</span> (default: 30)</div><div class="line">      --pprofArgs=   Extra arguments <span class="keyword">for</span> pprof</div><div class="line"></div><div class="line">Output Options:</div><div class="line">  <span class="_">-f</span>, --file=        Output file name (must be .svg) (default: torch.svg)</div><div class="line">  -p, --print        Print the generated svg to stdout instead of writing to file</div><div class="line">  -r, --raw          Print the raw call graph output to stdout instead of creating a flame graph; use with Brendan Gregg<span class="string">'s flame</span></div><div class="line">                     graph perl script (see https://github.com/brendangregg/FlameGraph)</div><div class="line">      --title=       Graph title to display in the output file (default: Flame Graph)</div><div class="line">      --width=       Generated graph width (default: 1200)</div><div class="line">      --hash         Colors are keyed by function name hash</div><div class="line">      --colors=      set color palette. choices are: hot (default), mem, io, wakeup, chain, java, js, perl, red, green, blue,</div><div class="line">                     aqua, yellow, purple, orange</div><div class="line">      --cp           Use consistent palette (palette.map)</div><div class="line">      --reverse      Generate stack-reversed flame graph</div><div class="line">      --inverted     icicle graph</div><div class="line"></div><div class="line">Help Options:</div><div class="line">  -h, --help         Show this help message</div></pre></td></tr></table></figure>
<p>通常情况下，我们只需要关注-u参数与-f参数即可，运行如下命令进行CPU采样，输出svg格式火焰图：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">go-torch -u http://xxxx.baidu.com:2021/debug/pprof/profile?seconds=120</div></pre></td></tr></table></figure>
<p>go-torch运行输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">INFO[10:57:29] Run pprof command: go tool pprof -raw -seconds 30 http://xxxx.baidu.com:2021/debug/pprof/profile?seconds=120</div><div class="line">INFO[10:58:00] Writing svg to torch.svg</div></pre></td></tr></table></figure>
<p>FlameGrpah文件：<a href="torch.svg">torch.svg</a></p>
<h3 id="FlameGraph-火焰图分析"><a href="#FlameGraph-火焰图分析" class="headerlink" title="FlameGraph-火焰图分析"></a>FlameGraph-火焰图分析</h3><p>许多人对火焰图的理解有歧义，有些似懂非懂，按照自己的主观意识去解读，导致陷入误区。要使用火焰图进行性能分析，首先需要明确火焰图<strong>x轴</strong>与<strong>y轴</strong>的确切含义。</p>
<p><strong><em>y 轴表示调用栈，每一层都标识一个函数，调用栈越深，火焰就越高，顶部就是当前在执行的函数。</em></strong></p>
<p><strong><em>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，表示它被抽到的次数多，执行的时间长（x 轴非时间轴，是所有的调用栈合并后，按函数字母顺序排列的）。因此，火焰图顶部，只要有”平顶”（plateaus），则表示该函数可能存在<font color="#ff0000" size="3">性能问题</font>。</em></strong></p>
<p>提示：svg格式，当移动鼠标至其中一栏时会显示”Tips”信息，包含采样数、占采样总数百分比等等信息，有关火焰图更详细的资料参考：<a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html" target="_blank" rel="external">cpu flame graph</a>。</p>
<p><img src="/2020/09/20/Golang性能分析/torch.svg" alt="示例火焰图"></p>
<p>上图中，可以很明显观察到<strong>encoding/json.Unmarshal</strong>函数<strong>耗费了40%的CPU时间</strong>，是系统的性能瓶颈。定位了性能瓶颈之后，我们应当思考如何优化了。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><p>json反序列化成为系统性能瓶颈，可以说在情理之内，预期之外。业务角度，我们的Golang模块强依赖的下游服务，返回了一个大JSON（大约几十KB），且字段嵌套层级较深，json反序列化耗时是情理之内的，但是耗费了惊人的40%的CPU时间是预期之外的。</p>
<p>为了解决这个问题，有如下几条思路：</p>
<ul>
<li>对下游返回JSON”瘦身”，未使用的字段不做解析；</li>
<li>使用LRU Cache，在内存中缓存已反序列化之后的Struct；</li>
<li>使用性能更高的开源json序列化方案；</li>
</ul>
<p>如何进行性能调优，解决文章中的Case，笔者将会在新的文章中阐述思路，本文不做过多叙述。</p>
<h1 id="联系作者"><a href="#联系作者" class="headerlink" title="联系作者"></a>联系作者</h1><p>有更好的”性能调优”方式，也欢迎一块儿交流一下（邮箱：luckydreamcatcher@163.com，微信号：15210466756）；</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zhuanlan.zhihu.com/p/51559344" target="_blank" rel="external">Go Pprof</a></p>
<p><a href="http://www.graphviz.org/download/source/" target="_blank" rel="external">graphviz</a></p>
<p><a href="http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html" target="_blank" rel="external">cpu flame graph</a></p>
<p><a href="https://www.ruanyifeng.com/blog/2017/09/flame-graph.html" target="_blank" rel="external">如何读懂火焰图</a></p>
<p><a href="https://ichrisking.github.io/2018/03/08/FlameGraph/" target="_blank" rel="external">FlameGraph安装指南</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2018/02/03/bloom-filter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/02/03/bloom-filter/" itemprop="url">
                  bloom filter（布隆过滤器）
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-03T00:21:14+08:00">
                2018-02-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>在互联网后台的开发工作中，笔者会经常遇到各种各样的<strong><em>白名单</em></strong>业务场景，比如以下典型场景：</p>
<ol>
<li>现有1亿个用户<code>user_id</code>，如何快速判断一个<code>user_id</code>是否在该白名单内</li>
<li>网络爬虫解析出一个页面的<code>url</code>清单，如何快速判断该<code>url</code>是否已经被抓取过</li>
<li>现有1亿个<code>user_id</code>，如何快速判断哪些<code>user_id</code>曾重复出现</li>
<li>服务器收到来自某个<code>ip</code>地址的请求，快速判断该<code>ip</code>地址是否在黑名单</li>
<li>……</li>
</ol>
<p>熟悉数据结构的读者，略微思考一下，便知以上若干问题的核心需求是：<strong><em>设计一个内存占用少且又高效的查找算法/数据结构。</em></strong> 以场景1为例，大多数读者首先想到的数据结构为<strong><em>哈希表</em></strong>，任意元素均可在<code>O(1)</code>时间复杂度内快速完成查找。</p>
<p>假设哈希表的装载因子为0.5（实践中比较常见的取值），粗略计算一下1亿个int类型<code>user_id</code>的内存占用约为<code>745MB</code>，一个白名单要占用如此多的内存空间，这显然是不可接受的。那么我们如何既能达成我们的目的，又占用比较小的内存呢？</p>
<p>一个<code>user_id</code>是否在白名单之内，只可能存在两种取值——是/否，从<strong><em>香农信息论</em></strong> 角度来看，使用1个<code>bit</code>即可表示是/否两种取值。一个<code>int</code>类型变量可存储<code>2^32</code>种取值，而当前业务场景下我们仅仅需要<code>0</code>和<code>1</code>两种状态便可（存储4种状态使用2个<code>bit</code>，存储8种状态使用3个<code>bit</code>，以此类推…）。存储1亿个<code>bit</code>占用空间约为<code>11MB</code>，大大减少了内存占用，这便是<code>Bitmap</code>数据结构。</p>
<h2 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h2><p><code>Bitmap</code>是一种紧凑的数据结构。以场景1为例，首先在内存中连续分配1亿个<code>bit</code>，要判断<code>user_id</code>为<code>1000</code>的用户是否在白名单之内，只需获取<code>bit</code>序列的第<code>1000</code>位<code>bit</code>的状态（1：<code>user_id</code>在白名单，0：<code>user_id</code>不在白名单）。如下为<code>c</code>语言版本的示例代码（也可查看笔者的<a href="https://github.com/keepalive555/study/blob/master/bitmap/bitmap.c" target="_blank" rel="external"><code>github</code></a>）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 1024</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SHIFT 5</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MASK 0xffffffff</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> bitmap[MAXSIZE / (<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>) * <span class="number">8</span>) + <span class="number">1</span>];</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 置位操作</span></div><div class="line">    bitmap[n &gt;&gt; SHIFT] |= <span class="number">1</span> &lt;&lt; (n &amp; MASK);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">clr</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 复位操作</span></div><div class="line">    bitmap[n &gt;&gt; SHIFT] &amp;= ~(<span class="number">1</span> &lt;&lt; (n &amp; MASK));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</div><div class="line">    <span class="comment">// 检测是否置位</span></div><div class="line">    <span class="keyword">int</span> i = n &gt;&gt; SHIFT;</div><div class="line">    <span class="keyword">if</span>(bitmap[i] &amp; (<span class="number">1</span> &lt;&lt; (n &amp; MASK)))</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> n = <span class="number">1023</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"space: %d\n"</span>, <span class="keyword">sizeof</span>(bitmap) / <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>));</div><div class="line">    <span class="built_in">set</span>(n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"has set flag: %d\n"</span>, test(n));</div><div class="line">    clr(n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"has set flag: %d\n"</span>, test(n));</div><div class="line">    <span class="built_in">set</span>(n);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"has set flag: %d\n"</span>, test(n));</div><div class="line">    clr(n);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Bitmap</code>类似于哈希表，哈希规则便是将数字<code>n</code>映射到<code>Bitmap</code>第<code>n</code>个<code>bit</code>上。因此<code>Bitmap</code>在实际应用中存在一处问题——当<code>n</code>取值特别大时，<code>Bitmap</code>占用空间也会比较大。在此业务场景下，<code>Bitmap</code>数据结构是不合理的，所以便衍生出了<code>Bloom Filter</code>。</p>
<h2 id="Bloom-Filter"><a href="#Bloom-Filter" class="headerlink" title="Bloom Filter"></a>Bloom Filter</h2><p><code>Bloom Filter</code>，中文译名布隆过滤器，是1970年由布隆提出来。布隆过滤器可以用于检索一个元素是否在一个集合中。朴素的讲，<code>BloomFilter</code>在<code>Bitmap</code>的基础上，将<code>Hash</code>函数的由一个扩展至多个。判断一个元素是否在一个集合中，仅需判断经过这些<code>Hash</code>函数后的值是否置位。布隆过滤器优点是<strong><em>空间复杂度和时间复杂度</em></strong> 都优于一般的算法，缺点是<strong><em>有一定的误识别率</em></strong> ，删除困难。</p>
<p><img src="/2018/02/03/bloom-filter/bloom-filter.png" alt="布隆过滤器"></p>
<h3 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h3><p>假设所选<code>Hash</code>函数在散列空间内分布均匀，即散列到每一个位置的概率相等（对于Hash函数的核心诉求）。假设<code>Bit</code>数组的大小为<code>m</code>，<code>k</code>为<code>Hash</code>函数的个数。</p>
<p><code>Bit</code>数组中某一位位置在元素插入时的<code>Hash</code>操作中没有被置位<code>1</code>的概率是：</p>
<p><img src="/2018/02/03/bloom-filter/1.png" alt="1"></p>
<p><code>k</code>个<code>Hash</code>函数散列之后该位置仍未被置位<code>1</code>的概率是：</p>
<p><img src="/2018/02/03/bloom-filter/2.png" alt="2"></p>
<p>连续插入<code>n</code>个元素，该位置仍未被置位<code>1</code>的概率是：</p>
<p><img src="/2018/02/03/bloom-filter/3.png" alt="3"></p>
<p>对立事件，该位为<code>1</code>的概率为：</p>
<p><img src="/2018/02/03/bloom-filter/4.png" alt="4"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p><code>C</code>语言实现请参考笔者<code>Github</code>：<a href="https://github.com/keepalive555/DataStructure/blob/master/bitmap/bloomfilter.c" target="_blank" rel="external">bloomfilter.c</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://matthias.vallentin.net/course-work/cs270-s11.pdf" target="_blank" rel="external">Bloom Filter Pagers</a></p>
<p><a href="https://www.cnblogs.com/liyulong1982/p/6013002.html" target="_blank" rel="external">Bloom Filter</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2018/01/08/Python-list实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2018/01/08/Python-list实现/" itemprop="url">
                  Python list实现
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-08T21:57:35+08:00">
                2018-01-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本文所讲<code>Python</code>实现均为<code>CPython</code>，需读者具备一定的<code>C</code>语言阅读能力。本博文参考了<strong><em>《Python源码剖析》</em></strong>与<code>Python2.7</code>源码。<code>PyListObject</code>采用顺序存储（而非链式存储），熟悉<code>数据结构</code>的读者，能很容易明白本博文所讲内容。</p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><code>PyListObject</code>是<code>Python</code>提供的<code>List</code>容器实现，与<code>C++ STL</code>中的<code>vector</code>实现机制相近。<code>PyListObject</code>是变长对象同时也是可变对象（很显然，不同时刻<code>List</code>中可以存在不同数目的元素）。</p>
<p><code>PyListObject</code>定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">	PyObject_VAR_HEAD</div><div class="line">	PyObject **ob_item;</div><div class="line">	<span class="keyword">int</span> allocated;</div><div class="line">&#125; PyListObject;</div></pre></td></tr></table></figure>
<p><code>PyObject_VAR_HEAD</code>中的<code>ob_size</code>与<code>PyListObject</code>中的<code>allocated</code>字段分别标识了容器的现有<strong><em>元素个数（size）</em></strong>与<strong><em>容器容量（capacity）</em></strong>。<code>ob_item</code>为指向<code>PyObject *</code>的指针（即<code>PyObject *</code>数组），是<code>PyListObject</code>实现顺序存储的数组。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="1、创建对象"><a href="#1、创建对象" class="headerlink" title="1、创建对象"></a>1、创建对象</h3><p><code>Python</code>提供了唯一创建<code>List</code>的函数——<code>PyList_New</code>。下面是简化的后<code>Python</code>创建<code>PyListObject</code>对象的过程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXFREELISTS 80</span></div><div class="line"><span class="keyword">static</span> PyListObject *free_lists[MAXFREELISTS];</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> num_free_ists = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function">PyObject *<span class="title">PyList_New</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">	PyListObject *op;</div><div class="line">	<span class="keyword">size_t</span> nbytes;</div><div class="line">	<span class="comment">// 判断int类型是否溢出，若溢出则返回内存分配失败</span></div><div class="line">	nbytes = size * <span class="keyword">sizeof</span>(PyObject *);</div><div class="line">	<span class="keyword">if</span>(nbytes / <span class="keyword">sizeof</span>(PyObject *) != (<span class="keyword">size_t</span>)size) &#123;</div><div class="line">		<span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//</span></div><div class="line">	<span class="keyword">if</span>(num_free_lists) &#123;</div><div class="line">		<span class="comment">// 缓冲池可用，则从缓冲池取一可用List</span></div><div class="line">		num_free_lists--;</div><div class="line">		op = free_lists[num_free_lists];</div><div class="line">		_Py_NewReference((PyObject *)op);</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		<span class="comment">// 缓冲池不可用，直接新建对象并为Python中的自动垃圾收集机制做一些工作</span></div><div class="line">		op = PyObject_GC_New(PyListObject, &amp;PyList_Type);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="keyword">if</span>(size &lt;= <span class="number">0</span>) &#123;</div><div class="line">		op-&gt;ob_item = <span class="literal">NULL</span>;</div><div class="line">	&#125; <span class="keyword">else</span> &#123;</div><div class="line">		op-&gt;ob_item = (PyObject **)PyMem_MALLOC(nbytes);</div><div class="line">		<span class="built_in">memset</span>(op-&gt;ob_item, <span class="number">0</span>, nbytes);</div><div class="line">	&#125;</div><div class="line">	op-&gt;ob_size = size;</div><div class="line">	op-&gt;allocated = size;</div><div class="line">	<span class="keyword">return</span> (PyObject *)op;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>PyListObject</code>对象分为两部分：①<code>PyListObject</code>对象②<code>PyListObject</code>对象容纳的<code>PyObject</code>元素。</p>
<h3 id="2、设置元素"><a href="#2、设置元素" class="headerlink" title="2、设置元素"></a>2、设置元素</h3><p>前面提到<code>PyListObject</code>是顺序存储，可以<strong><em>随机访问</em></strong>。通过下标设置<code>List</code>中元素值，是由<code>PyList_SetItem</code>函数实现的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyList_SetItem</span><span class="params">(<span class="keyword">register</span> PyObject *op, <span class="keyword">register</span> <span class="keyword">int</span> i, <span class="keyword">register</span> PyObject *new_item)</span> </span>&#123;</div><div class="line"> 	<span class="comment">// 保存指向旧元素的指针，用于减少引用计数</span></div><div class="line">	<span class="keyword">register</span> PyObject *olditem;</div><div class="line">	<span class="keyword">register</span> PyObject **p;</div><div class="line">	<span class="comment">// 检查索引值得合法性</span></div><div class="line">	<span class="keyword">if</span>(i &lt; <span class="number">0</span> || i&gt;= (PyListObject)op-&gt;ob_size) &#123;</div><div class="line">		<span class="comment">// 报索引错误</span></div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 设置元素</span></div><div class="line">	p = ((PyListObject*)op)-&gt;ob_item + i;</div><div class="line">	olditem = *p;</div><div class="line">	Py_XDECREF(olditem);</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3、插入元素"><a href="#3、插入元素" class="headerlink" title="3、插入元素"></a>3、插入元素</h3><p>了解<code>顺序存储</code>的读者，很容易想到新元素的插入会导致元素的移动。<code>PyListObject</code>的实现也不例外，而这其中又牵扯了<code>PyListObject.ob_item</code>的<strong><em>扩容</em></strong>与<strong><em>缩容</em></strong>（参考<code>Redis</code>或者其它若干软件的实现，都会有类似机制）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">PyList_Insert</span><span class="params">(PyObject *op, Py_ssize_t where, PyObject *new_item)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> insl((PyListObject *)op, where, newitem);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">insl</span><span class="params">(PyListObject *self, Py_ssize_t where, PyObject *v)</span> </span>&#123;</div><div class="line">	Py_ssize_t i, n = self-&gt;ob_size;</div><div class="line">	PyObject **items;</div><div class="line">	<span class="comment">// 调整列表容量</span></div><div class="line">	<span class="keyword">if</span>(list_resize(self, n+<span class="number">1</span>) == <span class="number">-1</span>)</div><div class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">	<span class="comment">// 确定插入点</span></div><div class="line">	<span class="keyword">if</span>(where &lt; <span class="number">0</span>) &#123;</div><div class="line">		<span class="comment">// 负数索引</span></div><div class="line">		where += n;</div><div class="line">		<span class="keyword">if</span>(where &lt; <span class="number">0</span>)</div><div class="line">			where = <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">if</span>(where &gt; n)</div><div class="line">		where = n;</div><div class="line">	<span class="comment">// 插入元素</span></div><div class="line">	items = self-&gt;ob_item;</div><div class="line">	<span class="keyword">for</span>(i = n; --i &gt;= where; )</div><div class="line">		<span class="comment">// 从后往前将元素后移一个单位，空出新元素存储单元</span></div><div class="line">		item[i+<span class="number">1</span>] = item[i]</div><div class="line">	<span class="comment">// 使用宏Py_INCREF增加元素v的引用计数</span></div><div class="line">	Py_INCREF(v);</div><div class="line">	item[where] = v;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中函数<code>list_resize</code>为<code>PyListObject</code>对象<strong><em>扩容</em></strong>与<strong><em>缩容</em></strong>的关键。<code>list_resize</code>函数的实现如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">list_resize</span><span class="params">(PyObjectList *self, <span class="keyword">int</span> newsize)</span> </span>&#123;</div><div class="line">	PyObject **items;</div><div class="line">	<span class="keyword">size_t</span> new_allocated;</div><div class="line">	<span class="keyword">int</span> allocated = self-&gt;allocated;</div><div class="line">	<span class="comment">// 不需要申请内存</span></div><div class="line">	<span class="keyword">if</span>(allocated &gt;= newsize &amp;&amp; newsize &gt;= (allocated &gt;&gt; <span class="number">1</span>)) &#123;</div><div class="line">		self-&gt;ob_size = newsize;</div><div class="line">		<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 计算重新申请内存的大小</span></div><div class="line">	new_allocated = (newsize &gt;&gt; <span class="number">3</span>) + (newsize &lt; <span class="number">9</span> ? <span class="number">3</span> : <span class="number">6</span>) + newsize;</div><div class="line">	<span class="keyword">if</span>(newsize == <span class="number">0</span>)</div><div class="line">		new_allocated = <span class="number">0</span>;</div><div class="line">	<span class="comment">// 扩展列表</span></div><div class="line">	items = self-&gt;ob_items;</div><div class="line">	<span class="comment">// 最终调用c语言的realloc</span></div><div class="line">	PyMem_RESIZE(item, PyObject *, new_allocated);</div><div class="line">	self-&gt;ob_itme = items;</div><div class="line">	self-&gt;ob_size = newsize;</div><div class="line">	self-&gt;allocated = new_allocated;</div><div class="line">	<span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当<code>List</code>新的元素个数<code>newsize</code>，满足条件：<code>allocated/2 &lt;= newsize &lt;= allocated</code>时，不需要进行<code>realloc</code>。当<code>newsize &gt;= allocated</code>时，<code>PyObjectList</code>会进行<strong><em>扩容</em></strong>操作，当<code>newsize &lt; allocated/2</code>时<code>PyObjectList</code>会进行<strong><em>缩容</em></strong>操作。</p>
<h2 id="对象池"><a href="#对象池" class="headerlink" title="对象池"></a>对象池</h2><p><code>CPython</code>为了解决频繁创建对象带来的性能问题（大多数对性能要求较高的<code>C</code>程序均采用类似机制），采用了大量的<code>对象池</code>技术——<code>PyListObject</code>的实现也不例外。如果读者对此类技术不熟悉，请参阅<strong><em>对象池</em></strong>设计模式。</p>
<p>在如上<code>PyList_New</code>函数的实现代码中，<code>free_lists</code>指针数组便是用于<code>PyListObject</code>创建的对象池。我们可以看到如果存在可用的<code>PyListObject</code>，<code>Python</code>便会从<code>对象池</code>中取出并返回一个<code>PyListObject</code>对象。那么<code>PyListObject</code>对象是<strong><em>何时、如何</em></strong>归还给对象池的呢？答案就在销毁<code>PyListObject</code>的<code>list_dealloc</code>函数里。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">list_dealloc</span><span class="params">(PyListObject *op)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> i;</div><div class="line">	<span class="keyword">if</span>(op-&gt;ob_item != <span class="literal">NULL</span>) &#123;</div><div class="line">		i = op-&gt;ob_size;</div><div class="line">		<span class="keyword">while</span>(--i &gt;= <span class="number">0</span>) &#123;</div><div class="line">			Py_XDECREF(op-&gt;ob_item[i]);</div><div class="line">		&#125;</div><div class="line">		PyMem_FREE(op-&gt;ob_item);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">// 释放PyListObject自身</span></div><div class="line">	<span class="keyword">if</span>(num_free_lists &lt; MAXFREELISTS &amp;&amp; PyList_CheckExact(op))</div><div class="line">		free_lists[num_free_lists++] = op;</div><div class="line">	<span class="keyword">else</span></div><div class="line">		op-&gt;ob_type-&gt;tp_free((PyObject *)op);</div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/12/29/SkipList/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/29/SkipList/" itemprop="url">
                  SkipList研究
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-29T00:37:10+08:00">
                2017-12-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>作为一名学渣，每次回头去翻看一下大学课程的基础知识，总会有不同的感受。笔者也总想着把自己工作中领悟的做归纳。关于查找算法，思想大概可以归类为三类（大神请绕路）：</p>
<ul>
<li>顺序查找</li>
<li>二分查找（插入查找、斐波拉切查找…）</li>
<li>哈希查找</li>
</ul>
<p>顺序查找是我们常用的遍历。在对性能要求比较高的业务场景下，我们便需要考虑其他更好的实现方式了（例如：为了避免全表扫描，数据库通过<code>B+ Tree</code>索引提高查找效率）。哈希查找，时间复杂度为<code>O(1)</code>，是一种常见且应用广泛的查找算法。本文将在剩余篇幅对二分查找法进行吐槽。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>咦？今天我们讨论的不是<code>SkipList</code>吗，为什么会谈到二分查找法，接下来笔者将阐述一下原因。在实际工程应用中，算法与数据结构是相辅相成的，相互依存，相互影响的， 没有<code>数据结构</code>支撑的算法只能是空中阁楼。接下来，我们思考尝试为二分查找（或类似思想）寻找一个适合的<strong><em>数据结构</em></strong>。</p>
<p>通常会从<code>CRUD</code>（即增、删、改、查）四个角度，结合具体应用场景去衡量一个数据结构的适用性。我们知道数据的存储方式分为两种：①顺序存储②链式存储。<strong>顺序存储</strong>中，有序列表的元素在内存中紧紧相连，可以<strong><em>随机访问</em></strong>（直接用下标访问，时间复杂度<code>O(1)</code>），能用二分查找法快速定位节点。但是顺序存储对<code>增、删</code>操作的处理比较费力（当删除列表中一个元素时，列表应当将该元素后面的元素前移，填补空的节点，同样增加元素时亦是如此）。</p>
<p>顺序存储不适用于<code>增 、删</code>操作频繁的应用场景，那么我们考虑一下<strong><em>链式存储</em></strong>。<strong><em>链表</em></strong>能很好的处理<code>增、删</code>频繁的场景。但是链表一般<strong><em>顺序访问</em></strong>（即读取第一个元素后才可以读取第二个元素，以此类推），显然传统的链表数据结构无法应用二分的思想进行快速查找。</p>
<p>聪明的人们结合<code>二叉树</code>，发明了<strong><em>二叉查找树</em></strong>———既可以二分查找，又能够快速<code>添加、删除</code>元素的数据结构。这正是我们期望的能够应用二分查找的完美数据结构吗？很遗憾，并不是。二叉查找树在最坏情况下可能变成一个链表。于是，在二分查找树的基础上，就出现了<code>AVL</code>平衡树。<code>AVL</code>树在<code>增、删</code>节点时，为了保持树的平衡，会进行左旋，右旋操作，增加了<code>增、删</code>操作的复杂度。于是乎根据人们在发明了<code>B-Tree</code>，<code>B+ Tree</code>，<code>红黑树</code>等。但是<code>AVL</code>树实现起来比较复杂，平衡操作较难理解。</p>
<p>所以便有了<code>SkipList</code>。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>百度搜索网上一些<code>SkipList</code>的实现，代码多多少少存在一些瑕疵。笔者根据自己对<code>SkipList</code>的理解，结合网上的一些实现，整理出了一份<code>C</code>语言版本的<code>SkipList</code>实现。读者可以参阅笔者的<code>GitHub</code>，源文件：<a href="https://github.com/keepalive555/study/blob/master/skiplist/skiplist.c" target="_blank" rel="external">https://github.com/keepalive555/study/blob/master/skiplist/skiplist.c</a>。</p>
<p>其中<code>SkipList</code>新建<code>Node</code>节点，随机获取节点<code>level</code>值的<code>random_level</code>函数（源码如下所示），是笔者摘抄自<code>Redis</code>源码。<strong><em>该函数是保证<code>SkipList</code>的<code>CRUD</code>操作时间复杂度为</em></strong>O(logN)<strong><em>的核心所在</em></strong>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_LEVEL 32</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> P 0.25</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">random_level</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;  </div><div class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;  </div><div class="line">    <span class="keyword">while</span> ((random() &amp; <span class="number">0xFFFF</span>) &lt; (P * <span class="number">0xFFFF</span>))  </div><div class="line">        level += <span class="number">1</span>;  </div><div class="line">    <span class="keyword">return</span> (level &lt; MAX_LEVEL) ? level : MAX_LEVEL;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/12/23/raft协议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/23/raft协议/" itemprop="url">
                  Raft协议
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-23T21:14:30+08:00">
                2017-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式，很多初学者对这个词的第一印象——高大上技术范儿。抛开技术细节不谈，纵观后台技术的发展，存在着普遍适用的规律，一项新技术的诞生，总是解决一些现有架构无法解决的问题。如果读者凭空去学习分布式，便容易坠入云里雾里。本文作为笔者自己学习的一个梳理，以实际问题出发阐述了笔者对<code>Raft</code>协议的理解。本文并不对<code>Raft</code>协议的实现机制做详细的描述，只是从一个新手解决问题的角度去阐述<code>Raft</code>协议做了些什么，不正确的地方请读者指正（邮箱：<a href="mailto:dreamcatchwang1991@gmail.com" target="_blank" rel="external">dreamcatchwang1991@gmail.com</a>）。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>以经典单数据库实例架构（这也是很多企业级应用的典型架构）为例，所有的业务数据均存储于单机数据库，当数据库实例<code>Crash</code>了以后，业务便受到影响，在大多数情况下，这种<code>Crash</code>对企业业务的影响是可控范的。然而在互联网应用中，哪怕是一分钟的<code>Crash</code>对企业来说也是致命的，比如前段时间，美团的外卖系统出现崩溃，整个服务停摆几个小时，造成大量用户流失到饿了么平台。 </p>
<p>笔者尝试根据自己的经验去解决该问题，为了让单机数据库实例在<code>Crash</code>了以后,整个系统仍然保持可用，我们很容易想到的一个策略——冗余（比如你在单位请假了需要有人代替你继续工作而不影响业务）。我们增加了一台数据库实例<code>B</code>（原来的数据库实例用<code>A</code>表示），在实例<code>A</code>挂掉了之后，我们期望<code>B</code>可以代替<code>A</code>继续提供服务，<strong><em>所以<code>B</code>与<code>A</code>必须具备一样的数据</em></strong>，在分布式里面这个称作<strong><em>一致性</em></strong>。<code>Raft</code>协议为<strong><em>分布式一致性协议</em></strong>的一种实现，主要目标就是解决上述这类问题。</p>
<p>脱离现有的<code>MySQL</code>，<code>Redis</code>，<code>Kafka</code>等高可用方案（因为这些系统为了性能而做出一些折中），我们根据自己的诉求，去设计一个高可用的存储系统，需要注意哪些问题呢？假设我们的存储系统有<code>A</code>,<code>B</code>,<code>C</code>等3个节点用来保持高可用，那我们该怎么保持<code>A</code>,<code>B</code>,<code>C</code>3个节点内数据的一致性呢？</p>
<ul>
<li>一致性由客户端保证还是服务端保证</li>
<li>如何保证<code>A,B,C</code>或更多节点的数据一致性</li>
</ul>
<p>首先分析第一个问题，假设一致性工作是由客户端保证的（客户端向<code>A</code>写入数据的同时向<code>B</code>和<code>C</code>写入数据，为保证<code>A,B,C</code>的一致性，需<code>A,B,C</code>3个节点全部写入成功，客户端回才判定写入成功），我们可能会遇到如下情况:</p>
<ul>
<li><code>B</code>下线了一段时间又重新上线，因为客户端未保存<code>B</code>处于下线状态这段时间的数据，所以<code>B</code>中就会缺失这部分数据，因而<code>B</code>中数据会与<code>A</code>与<code>C</code>中数据不一致。</li>
<li>客户端向<code>A</code>与<code>C</code>中写入数据成功，但向<code>B</code>中写入数据失败，这次写入应当被认定为失败（因为<code>A</code>,<code>B</code>,<code>C</code>中数据不一致，也无法通过其他途径达到一致），我们期望整个系统可以表现的犹如一个<strong><em>事务</em></strong>，要么全部成功，要么全部失败回滚修改，客户端无法提供这种机制。</li>
</ul>
<p>综上，<strong><em>由客户端保证数据的一致性是不可取的</em></strong>。 </p>
<p>我们将一致性保证工作放在服务端实现，那么我们如何保证<code>A,B,C</code>三节点数据的一致性呢？首先我们思考一个问题，<strong><em>我们无法预知<code>A,B,C</code>三个节点中哪个节点会意外挂掉，所以客户端不应该至同单一节点建立联系</em></strong>，也就是说——<code>A,B,C</code>3个节点对外应当表现为一个整体，也就是集群<code>Cluster</code>。那么客户端该如何向<code>A,B,C</code>组成的集群写入数据？以下是笔者想到的实现方式：</p>
<ul>
<li>所有客户端均向<code>A,B,C</code>中某一节点（比如<code>A</code>）写入数据，由该节点将数据拷贝至其它节点以达到一致性。</li>
<li>向建立连接的节点写入数据，比如<code>客户端1</code>同<code>A</code>建立连接，<code>客户端1</code>向<code>A</code>写入数据，<code>客户端2</code>同<code>B</code>建立连接，<code>客户端2</code>向<code>B</code>写入数据，以此类推。</li>
</ul>
<p>读者是否觉得以上两种实现方式似曾相识——这和<strong><em>并发编程</em></strong>下的并发更改共享变量问题相似，由经验我们可知，我们最好是将对共享的操作<strong><em>串行，有序的</em></strong>执行。同样，如果多个客户端通过多个节点向集群写入数据，为了达到每个节点都有一份完整数据的目的，多个节点间会进行通讯，数据合并，而这其中又牵扯了数据的顺序等许多问题，工程实现起来比较复杂。<br>当然不是说不可以，笔者没见过这么做的~ ~）</p>
<p>方式一为目前流行的一致性解决思路，<code>Raft</code>协议采用了该思路，<code>Raft</code>协议解决了方式一面临的两大问题：</p>
<ul>
<li>集群启动（或者写入节点下线）时，如何选举出一个节点作为写入节点</li>
<li>写入节点如何与其它节点通讯，复制数据，保持数据在各节点的一致性</li>
</ul>
<p>以上两大问题便是<code>Raft</code>协议的两大功能：</p>
<ul>
<li><code>Leader Election</code></li>
<li><code>Log Replication</code></li>
</ul>
<p>分布式中任何环节都是不可靠的，实际问题比本人论述的复杂的多，但明确了上述问题，再去研究<code>Raft Paper</code>时，读者便可以快速掌握<code>Raft</code>协议。</p>
<p>建议大家观看<code>Raft</code>协议动画，简单明了生动：<a href="http://thesecretlivesofdata.com/raft/" target="_blank" rel="external">http://thesecretlivesofdata.com/raft/</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] <a href="https://raft.github.io/raft.pdf" target="_blank" rel="external">Raft Pager</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/12/23/线段树应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/23/线段树应用/" itemprop="url">
                  线段树应用（编辑中）
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-23T02:25:15+08:00">
                2017-12-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>学习工作多年，逐渐悟得一名优秀的程序员应有的态度———<strong><em>优雅的解决问题</em></strong>。简而言之，解决问题并不是最终解，如何求得该问题的最优解才是一名优秀程序员应该考虑的问题。<code>360</code>同事对待问题的态度让我这种感觉愈发强烈。</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>最近笔者在考虑如下一个需求：</p>
<blockquote>
<p>现有一集团，内部网络划分为N多个子网（N&gt;100），该N多个子网网段互相之间不交叉。有一批告警数据，该数据里携带了产生告警事件的设备<code>IPv4</code>地址，现笔者需要根据设备<code>IPv4</code>地址，将这些告警数据按子网网段分类。</p>
</blockquote>
<p>以上问题可抽象为：</p>
<p>问题Q：存在区间[1, 100]，该区间是由[1, 10], [11, 20], [21, 30]…[91, 100]等子区间组成，现给定一个正整数N（1 &lt;= N &lt;= 100），求解N落在那个子区间。 </p>
<blockquote>
<p>注解：将N多个子网网段用区间（由计算机网络可知<code>IPv4</code>地址为32位无符号整数）的形式表现，比如子网网段<code>10.95.12.0/24</code>表示的<code>IPv4</code>地址范围为：<code>10.95.12.0</code> ~ <code>10.95.12.255</code>（即：<code>0xa5f0c00</code>~<code>0xaf0cff</code>），其他网段类推，由此可见该需求属于我们问题Q的同一类问题。</p>
</blockquote>
<p>我们尝试去解决问题Q，首先比较容易想到，也是实现比较简单的便是<strong><em>遍历</em></strong>[1, 10], [11, 20]…[91, 100]等所有子区间，用N与子区间的左右端点作比较，确定N所在的子区间。显而易见，该方法简单明了，时间复杂度为O(n)。</p>
<p>子区间数目越多，遍历一次花费的代价就越大，在海量数据的处理中，这显然是不可忍受的。我们观察到子区间[1, 10], [11, 20], [21, 30]…[91, 100]是连续的，于是我们自然而然的想到了二分查找与二叉搜索树，不同的是以前我们接触的大多是单个节点的查找，现在是范围（即：子区间）的查找，由此今天的主角便登场了——线段树（又名区间树）。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/12/22/IOLoop简述/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/12/22/IOLoop简述/" itemprop="url">
                  Tornado IOLoop图解
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-22T13:26:57+08:00">
                2017-12-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Tornado-IOLoop简述"><a href="#Tornado-IOLoop简述" class="headerlink" title="Tornado IOLoop简述"></a>Tornado IOLoop简述</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>笔者信奉这样一种哲学——“把书从薄读厚，然后从厚读薄”，<code>Tornado</code>源码犹如一部文学作品，汇集了众多优秀<code>Python</code>工程师的智慧结晶，奇思妙想让人拍手连连。一本好书每读一次，都有不同的感受，代码也是如此。为了能够在以后的工作学习中时时回顾品味一下，笔者决定将笔者对<code>Tornado</code>的理解以图记录下来。</p>
<p>在这里笔者推荐一款强大的在线绘图软件：<a href="https://www.draw.io/" target="_blank" rel="external">https://www.draw.io/</a>，想要<code>Visio</code>的专业，却不喜欢<code>Visio</code>笨重的读者绝对会让你好用到<code>Cry</code>。</p>
<h2 id="IOLoop图示"><a href="#IOLoop图示" class="headerlink" title="IOLoop图示"></a>IOLoop图示</h2><p><strong><em>注意：</em></strong> 对<code>IO</code>多路复用技术不了解的同学，可以先了解一下 <strong><em>阻塞/非阻塞，同步/异步，select，epoll</em></strong> 等概念。</p>
<p>笔者注意到，任何语言的事件循环（比如：<code>libev</code>，<code>nodejs</code>，…），最核心的<code>Feature</code>是相同的，不一样的只不过是实现方式，抽象层次不同，笔者将这些核心<code>Feature</code>总结如下：</p>
<ul>
<li>文件<code>IO</code>事件（比如：<code>socket</code>，<code>pipe</code>等<code>READ</code>，<code>WRITE</code>，<code>HUP</code>事件 …）</li>
<li>系统信号(比如：<code>SIGINT</code>,<code>SIGHUP</code>…)</li>
<li>定时器</li>
</ul>
<p><code>Tornado IOLoop</code>的实现也不例外，如下图所示：</p>
<p><img src="/2017/12/22/IOLoop简述/ioloop.jpg" alt="IOLoop示意图"></p>
<h2 id="IOLoop代码随笔"><a href="#IOLoop代码随笔" class="headerlink" title="IOLoop代码随笔"></a>IOLoop代码随笔</h2><p>以下是笔者对<code>IOLoop</code>核心方法<code>start</code>的源码注解，可以用于结合图示，加深理解。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">if</span> self._running:</div><div class="line">        <span class="comment"># IOLoop已经启动。</span></div><div class="line">        <span class="keyword">raise</span> RuntimeError(<span class="string">"IOLoop is already running"</span>)</div><div class="line">    self._setup_logging()  <span class="comment"># 开始安装日志模块。</span></div><div class="line">    <span class="keyword">if</span> self._stopped:</div><div class="line">        self._stopped = <span class="keyword">False</span>  <span class="comment"># 如果已经停止，则直接返回。</span></div><div class="line">        <span class="keyword">return</span></div><div class="line">    <span class="comment"># 获取当前线程的IOLoop实例。</span></div><div class="line">    old_current = getattr(IOLoop._current, <span class="string">"instance"</span>, <span class="keyword">None</span>)</div><div class="line">    IOLoop._current.instance = self  <span class="comment"># 将当前IOLoop实例置为self。</span></div><div class="line">    self._thread_ident = thread.get_ident()  <span class="comment"># 线程id。</span></div><div class="line">    self._running = <span class="keyword">True</span></div><div class="line"></div><div class="line">    <span class="comment"># signal.set_wakeup_fd closes a race condition in event loops:</span></div><div class="line">    <span class="comment"># a signal may arrive at the beginning of select/poll/etc</span></div><div class="line">    <span class="comment"># before it goes into its interruptible sleep, so the signal</span></div><div class="line">    <span class="comment"># will be consumed without waking the select.  The solution is</span></div><div class="line">    <span class="comment"># for the (C, synchronous) signal handler to write to a pipe,</span></div><div class="line">    <span class="comment"># which will then be seen by select.</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># In python's signal handling semantics, this only matters on the</span></div><div class="line">    <span class="comment"># main thread (fortunately, set_wakeup_fd only works on the main</span></div><div class="line">    <span class="comment"># thread and will raise a ValueError otherwise).</span></div><div class="line">    <span class="comment">#</span></div><div class="line">    <span class="comment"># If someone has already set a wakeup fd, we don't want to</span></div><div class="line">    <span class="comment"># disturb it.  This is an issue for twisted, which does its</span></div><div class="line">    <span class="comment"># SIGCHLD processing in response to its own wakeup fd being</span></div><div class="line">    <span class="comment"># written to.  As long as the wakeup fd is registered on the IOLoop,</span></div><div class="line">    <span class="comment"># the loop will still wake up and everything should work.</span></div><div class="line"></div><div class="line">    <span class="comment"># wakeup_fd是用来唤醒主事件循环（信号唤醒，或者从别的线程唤醒主线程）。</span></div><div class="line">    old_wakeup_fd = <span class="keyword">None</span></div><div class="line">    <span class="keyword">if</span> hasattr(signal, <span class="string">'set_wakeup_fd'</span>) <span class="keyword">and</span> os.name == <span class="string">'posix'</span>:</div><div class="line">        <span class="comment"># requires python 2.6+, unix.  set_wakeup_fd exists but crashes</span></div><div class="line">        <span class="comment"># the python process on windows.</span></div><div class="line"></div><div class="line">        <span class="comment"># Python2.6版本以上，Unix-like系统中，signal模块支持set_wakeup_fd方法。</span></div><div class="line">        <span class="comment"># Windows上siganl存在该方法，但是会crash。</span></div><div class="line">        <span class="keyword">try</span>:</div><div class="line">            old_wakeup_fd = signal.set_wakeup_fd(self._waker.write_fileno())</div><div class="line">            <span class="keyword">if</span> old_wakeup_fd != <span class="number">-1</span>:</div><div class="line">                <span class="comment"># Already set, restore previous value.  This is a little racy,</span></div><div class="line">                <span class="comment"># but there's no clean get_wakeup_fd and in real use the</span></div><div class="line">                <span class="comment"># IOLoop is just started once at the beginning.</span></div><div class="line">                signal.set_wakeup_fd(old_wakeup_fd)</div><div class="line">                old_wakeup_fd = <span class="keyword">None</span></div><div class="line">        <span class="keyword">except</span> ValueError:</div><div class="line">            <span class="comment"># Non-main thread, or the previous value of wakeup_fd</span></div><div class="line">            <span class="comment"># is no longer valid.</span></div><div class="line">            <span class="comment"># 参考signal的官方手册，set_wakeup_fd仅可在主线程中调用。</span></div><div class="line">            old_wakeup_fd = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="comment"># Prevent IO event starvation by delaying new callbacks</span></div><div class="line">            <span class="comment"># to the next iteration of the event loop.</span></div><div class="line">            <span class="comment"># ncallbacks记录了此次循环的回调函数个数，新增加的回调函数将要在下次循环被调用。</span></div><div class="line">            ncallbacks = len(self._callbacks)</div><div class="line"></div><div class="line">            <span class="comment"># Add any timeouts that have come due to the callback list.</span></div><div class="line">            <span class="comment"># Do not run anything until we have determined which ones</span></div><div class="line">            <span class="comment"># are ready, so timeouts that call add_timeout cannot</span></div><div class="line">            <span class="comment"># schedule anything in this iteration.</span></div><div class="line">            due_timeouts = []  <span class="comment"># 即将超时的任务。</span></div><div class="line">            <span class="keyword">if</span> self._timeouts:</div><div class="line">                now = self.time()</div><div class="line">                <span class="keyword">while</span> self._timeouts:</div><div class="line">                    <span class="keyword">if</span> self._timeouts[<span class="number">0</span>].callback <span class="keyword">is</span> <span class="keyword">None</span>:</div><div class="line">                        <span class="comment"># The timeout was cancelled.  Note that the</span></div><div class="line">                        <span class="comment"># cancellation check is repeated below for timeouts</span></div><div class="line">                        <span class="comment"># that are cancelled by another timeout or callback.</span></div><div class="line">                        heapq.heappop(self._timeouts)</div><div class="line">                        self._cancellations -= <span class="number">1</span></div><div class="line">                    <span class="keyword">elif</span> self._timeouts[<span class="number">0</span>].deadline &lt;= now:</div><div class="line">                        due_timeouts.append(heapq.heappop(self._timeouts))</div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="keyword">break</span></div><div class="line">                <span class="keyword">if</span> (self._cancellations &gt; <span class="number">512</span> <span class="keyword">and</span></div><div class="line">                        self._cancellations &gt; (len(self._timeouts) &gt;&gt; <span class="number">1</span>)):</div><div class="line">                    <span class="comment"># Clean up the timeout queue when it gets large and it's</span></div><div class="line">                    <span class="comment"># more than half cancellations.</span></div><div class="line">                    <span class="comment"># 如果定时任务取消数量大于512，并且超过总定时任务的半数，则清理self._timeouts，并重新平衡堆。</span></div><div class="line">                    self._cancellations = <span class="number">0</span></div><div class="line">                    self._timeouts = [x <span class="keyword">for</span> x <span class="keyword">in</span> self._timeouts</div><div class="line">                                      <span class="keyword">if</span> x.callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>]</div><div class="line">                    heapq.heapify(self._timeouts)</div><div class="line"></div><div class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(ncallbacks):</div><div class="line">                <span class="comment"># 执行回调函数。</span></div><div class="line">                self._run_callback(self._callbacks.popleft())</div><div class="line">            <span class="keyword">for</span> timeout <span class="keyword">in</span> due_timeouts:</div><div class="line">                <span class="comment"># 执行定时任务。</span></div><div class="line">                <span class="keyword">if</span> timeout.callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                    self._run_callback(timeout.callback)</div><div class="line">            <span class="comment"># Closures may be holding on to a lot of memory, so allow</span></div><div class="line">            <span class="comment"># them to be freed before we go into our poll wait.</span></div><div class="line">            due_timeouts = timeout = <span class="keyword">None</span>  <span class="comment"># 防止内存泄漏</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> self._callbacks:</div><div class="line">                <span class="comment"># If any callbacks or timeouts called add_callback,</span></div><div class="line">                <span class="comment"># we don't want to wait in poll() before we run them.</span></div><div class="line">                <span class="comment"># 如果发现新增的_callbacks，（回调函数执行时加入了新的回调函数）。</span></div><div class="line">                poll_timeout = <span class="number">0.0</span></div><div class="line">            <span class="keyword">elif</span> self._timeouts:</div><div class="line">                <span class="comment"># If there are any timeouts, schedule the first one.</span></div><div class="line">                <span class="comment"># Use self.time() instead of 'now' to account for time</span></div><div class="line">                <span class="comment"># spent running callbacks.</span></div><div class="line">                poll_timeout = self._timeouts[<span class="number">0</span>].deadline - self.time()  <span class="comment"># 距离将来最近一次定时任务的时间，wait该时间。</span></div><div class="line">                poll_timeout = max(<span class="number">0</span>, min(poll_timeout, _POLL_TIMEOUT))</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="comment"># No timeouts and no callbacks, so use the default.</span></div><div class="line">                <span class="comment"># 未发现新的回调函数与定时任务，则调用poll，等待IO事件，超时事件为3600秒。</span></div><div class="line">                poll_timeout = _POLL_TIMEOUT</div><div class="line"></div><div class="line">            <span class="keyword">if</span> <span class="keyword">not</span> self._running:</div><div class="line">                <span class="comment"># 如果回调函数中有调用stop的则，跳出事件循环。</span></div><div class="line">                <span class="keyword">break</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                <span class="comment"># clear alarm so it doesn't fire while poll is waiting for</span></div><div class="line">                <span class="comment"># events.</span></div><div class="line">                signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line"></div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="comment"># 等待IO事件，events_pairs内容为：[(fd, events), (fd, events), ]</span></div><div class="line">                event_pairs = self._impl.poll(poll_timeout)</div><div class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</div><div class="line">                <span class="comment"># Depending on python version and IOLoop implementation,</span></div><div class="line">                <span class="comment"># different exception types may be thrown and there are</span></div><div class="line">                <span class="comment"># two ways EINTR might be signaled:</span></div><div class="line">                <span class="comment"># * e.errno == errno.EINTR</span></div><div class="line">                <span class="comment"># * e.args is like (errno.EINTR, 'Interrupted system call')</span></div><div class="line"></div><div class="line">                <span class="comment"># poll陷入内核态以后，进程捕获到的信号会导致poll wait结束，并且错误码为EINTR。</span></div><div class="line">                <span class="keyword">if</span> errno_from_exception(e) == errno.EINTR:</div><div class="line">                    <span class="keyword">continue</span></div><div class="line">                <span class="keyword">else</span>:</div><div class="line">                    <span class="keyword">raise</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                signal.setitimer(signal.ITIMER_REAL,</div><div class="line">                                 self._blocking_signal_threshold, <span class="number">0</span>)</div><div class="line"></div><div class="line">            <span class="comment"># Pop one fd at a time from the set of pending fds and run</span></div><div class="line">            <span class="comment"># its handler. Since that handler may perform actions on</span></div><div class="line">            <span class="comment"># other file descriptors, there may be reentrant calls to</span></div><div class="line">            <span class="comment"># this IOLoop that modify self._events</span></div><div class="line">            self._events.update(event_pairs)</div><div class="line">            <span class="keyword">while</span> self._events:</div><div class="line">                fd, events = self._events.popitem()</div><div class="line">                <span class="keyword">try</span>:</div><div class="line">                    <span class="comment"># 获取file-like object，与IO事件的处理函数handler。</span></div><div class="line">                    fd_obj, handler_func = self._handlers[fd]</div><div class="line">                    <span class="comment"># 调用handler，处理fd_obj上发生的events事件，</span></div><div class="line">                    <span class="comment"># handler_func在add_handler时候，加入了对事件处理的wraps。</span></div><div class="line">                    handler_func(fd_obj, events)</div><div class="line">                <span class="keyword">except</span> (OSError, IOError) <span class="keyword">as</span> e:</div><div class="line">                    <span class="keyword">if</span> errno_from_exception(e) == errno.EPIPE:</div><div class="line">                        <span class="comment"># Happens when the client closes the connection</span></div><div class="line">                        <span class="comment"># 客户端关闭了同服务器的连接。</span></div><div class="line">                        <span class="keyword">pass</span></div><div class="line">                    <span class="keyword">else</span>:</div><div class="line">                        <span class="comment"># 处理异常。</span></div><div class="line">                        self.handle_callback_exception(self._handlers.get(fd))</div><div class="line">                <span class="keyword">except</span> Exception:</div><div class="line">                    self.handle_callback_exception(self._handlers.get(fd))</div><div class="line">            fd_obj = handler_func = <span class="keyword">None</span></div><div class="line"></div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        <span class="comment"># reset the stopped flag so another start/stop pair can be issued</span></div><div class="line">        self._stopped = <span class="keyword">False</span></div><div class="line">        <span class="keyword">if</span> self._blocking_signal_threshold <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            signal.setitimer(signal.ITIMER_REAL, <span class="number">0</span>, <span class="number">0</span>)</div><div class="line">        <span class="comment"># 还原前一个IOLoop实例（作者也说了这种情况基本没有...）</span></div><div class="line">        IOLoop._current.instance = old_current</div><div class="line">        <span class="keyword">if</span> old_wakeup_fd <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            signal.set_wakeup_fd(old_wakeup_fd)</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/11/13/Python内存回收机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/11/13/Python内存回收机制/" itemprop="url">
                  Python内存回收机制
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-13T23:28:54+08:00">
                2017-11-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/" itemprop="url" rel="index">
                    <span itemprop="name">编程语言</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程语言/源码分析/" itemprop="url" rel="index">
                    <span itemprop="name">源码分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python2-7内存回收机制-一"><a href="#Python2-7内存回收机制-一" class="headerlink" title="Python2.7内存回收机制(一)"></a>Python2.7内存回收机制(一)</h1><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p><code>Python</code>的内存回收采用<em>引用计数</em>机制。引用计数是一种简单而广泛使用的资源回收机制，例如<code>Linux</code>平台的<em>文件描述符</em>，<code>Windows</code>平台下的<em>内核对象</em>等均采用引用计数的方式进行管理。本文将结合<code>Python2.7</code>官方手册阐明<code>Python2.7</code>的<em>引用计数机制</em>（如无特殊说明，本文所提及的<code>Python</code>均为<code>CPython</code>）。</p>
<p><code>Python</code>语言在设计之初就是一门面向对象的语言，即一切皆为对象，在<code>Python</code>官方介绍通用对象结构<a href="https://docs.python.org/2/c-api/structures.html#c.PyObject" target="_blank" rel="external"><code>Common Object Structures</code></a>一文中，有这样一段话：</p>
<blockquote>
<p>All Python objects ultimately share a small number of fields at the beginning of the object’s representation in memory. These are represented by the<a href="https://docs.python.org/2/c-api/structures.html#c.PyObject" target="_blank" rel="external"><code>PyObject</code></a> and <a href="https://docs.python.org/2/c-api/structures.html#c.PyVarObject" target="_blank" rel="external"><code>PyVarObject</code></a> types, which are defined, in turn, by the expansions of some macros also used, whether directly or indirectly, in the definition of all other Python objects.</p>
</blockquote>
<p>简单来说，<code>Python</code>中所有对象的开始位置，都有一组成员变量，以<code>C</code>语言的两个自定义类型——<code>PyObject</code>与<code>PyVarObject</code>来表示（有兴趣的，可以通读<code>Common Object Structures</code>一文，或者参考《<code>Python源代码剖析</code>》一书，这里不做具体阐述)，<code>PyObject</code>与<code>PyVarObject</code>的开始位置都有一组相同的成员变量（分别由宏<code>PyObject_HEAD</code>，<code>PyObject_HEAD</code>扩展）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Py_ssize_t ob_refcnt;  <span class="comment">// 对象引用计数</span></div><div class="line">PyTypeObject *ob_type;  <span class="comment">// 指向对象类型结构体的指针（与本文无关不做具体阐述）</span></div></pre></td></tr></table></figure>
<p>由此可见，在<code>CPython</code>实现中，每个<code>Python</code>对象均有一个名为<code>ob_refcnt</code>的成员变量用于标识该对象的引用计数。而众所周知，在<code>Python</code>的实现中，变量只是保存了一个对象的引用（即指针），而非对象本身，所以每当一个<code>Python</code>对象被一个不同变量所引用时，对象的引用计数就会+1，相反当变量不再引用该对象时，该对象的引用计数就会-1，当对象的引用计数变为0时，该对象就会在未来的某个时间被<code>Python</code>的垃圾回收器所回收。</p>
<p>通过<code>Python</code>的<code>sys</code>模块的<code>getrefcount</code>方法可以获取<code>Python</code>对象的当前引用计数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="keyword">pass</span></div><div class="line"></div><div class="line">        a = A()</div><div class="line">     b = c = a</div><div class="line">     print(sys.getrefcount(a))</div></pre></td></tr></table></figure>
<pre><code>示例运行结果为4，比实际引用数量（a, b, c）多1，那么为什么会这样呢，`sys.getrefcount`的文档作出了说明：

&gt;Return the reference count of the *object*. The count returned is generally one higher than you might expect, because it includes the (temporary) reference as an argument to [`getrefcount()`](https://docs.python.org/2.7/library/sys.html#sys.getrefcount).

把对象当做参数调用`sys.getrefcount`方法会增加对象的一个临时引用计数。
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.nice-ai-life.com/2017/08/31/Huffman编码/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gatsby">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="枫叶居">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/31/Huffman编码/" itemprop="url">
                  Huffman编码
                </a>
              
            
          </h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-31T00:45:00+08:00">
                2017-08-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Alg/" itemprop="url" rel="index">
                    <span itemprop="name">Alg</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Huffman编码"><a href="#Huffman编码" class="headerlink" title="Huffman编码"></a>Huffman编码</h1><p><strong>注意：</strong> <a href="">原创技术博客，转载请注明原文地址</a>。</p>
<h2 id="Huffman编码简介"><a href="#Huffman编码简介" class="headerlink" title="Huffman编码简介"></a>Huffman编码简介</h2><p>依然记得初次接触<code>Huffman</code>编码，是在大一的《计算机组成原理》课程上，老师采用<code>Huffman</code>编码实现了一种<code>CPU</code>（虚拟机字节码同理）变长指令集。当时感觉特别神奇，后来又在《数据结构》课程上接触到了<code>Huffman Tree</code>（霍夫曼树），算是对<code>Huffman</code>编码有了一个比较全面的认识。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding: utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="string">"""Huffman编码Python实现。"""</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, score, value=None, lchild=None, rchild=None)</span>:</span></div><div class="line">        self.score = score</div><div class="line">        self.value = value</div><div class="line">        self.lchild = lchild</div><div class="line">        self.rchild = rchild</div><div class="line">        self.bit = <span class="number">0</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_huffman_tree</span><span class="params">(sequence)</span>:</span></div><div class="line"></div><div class="line">    char2frequency = dict()</div><div class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> sequence:</div><div class="line">        char2frequency.setdefault(c, <span class="number">0</span>)</div><div class="line">        char2frequency[c] += <span class="number">1</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_cmp</span><span class="params">(a, b)</span>:</span></div><div class="line">        delta = a.score - b.score</div><div class="line">        <span class="keyword">if</span> delta != <span class="number">0</span>:</div><div class="line">            <span class="keyword">return</span> sequence.index(a.value) - sequence.index(b.value)</div><div class="line">        <span class="keyword">return</span> delta</div><div class="line"></div><div class="line">    queue = [Node(char2frequency[x], x) <span class="keyword">for</span> x <span class="keyword">in</span> set(sequence)]</div><div class="line">    queue.sort(cmp=_cmp)</div><div class="line"></div><div class="line">    <span class="keyword">while</span> len(queue) &gt; <span class="number">1</span>:</div><div class="line">        lchild, rchild = queue.pop(), queue.pop()</div><div class="line">        lchild.bit, rchild.bit = <span class="number">0</span>, <span class="number">1</span></div><div class="line">        parent_node = Node(</div><div class="line">            lchild.score+rchild.score, lchild=lchild, rchild=rchild)</div><div class="line">        queue.insert(<span class="number">0</span>, parent_node)</div><div class="line">        queue.sort(key=<span class="keyword">lambda</span> o: o.score)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> queue[<span class="number">0</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_check_list</span><span class="params">(node)</span>:</span></div><div class="line"></div><div class="line">    stack = []</div><div class="line">    check_list = dict()</div><div class="line">    <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">or</span> stack:</div><div class="line">        <span class="keyword">while</span> node <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">            stack.append(node)</div><div class="line">            node = node.lchild</div><div class="line">        <span class="keyword">if</span> stack:</div><div class="line">            node = stack.pop()</div><div class="line">            <span class="keyword">if</span> node.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</div><div class="line">                sequence = [x.bit <span class="keyword">for</span> x <span class="keyword">in</span> stack]</div><div class="line">                sequence.append(node.bit)</div><div class="line">                check_list[node.value] = int(<span class="string">''</span>.join(map(str, sequence)), <span class="number">2</span>)</div><div class="line">            node = node.rchild</div><div class="line">    <span class="keyword">return</span> check_list</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    tree = generate_huffman_tree(<span class="string">'shootsheetjobwork'</span>)</div><div class="line">    check_list = generate_check_list(tree)</div><div class="line">    <span class="keyword">print</span> check_list</div></pre></td></tr></table></figure>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Gatsby" />
          <p class="site-author-name" itemprop="name">Gatsby</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
           
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">27</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gatsby</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
